## 목차

1.[운영체제의 개요](#1.-운영체제의-개요)   
2.[프로세스와 스레드](#2.-프로세스와-스레드)   
3.[CPU 스케줄링](#3.-CPU-스케줄링)   
4.[프로세스 동기화](#4.-프로세스-동기화)   
5.[교착 상태](#5.-교착-상태)   
6.[물리 메모리 관리](#6.-물리-메모리-관리)   
7.[가상 메모리의 기초](#7.-가상-메모리의-기초)      
8.[가상 메모리 관리](#8.-가상-메모리-관리)   
9.[입출력 시스템과 저장장치](#9.-입출력-시스템과-저장장치)   
10.[파일 시스템](#10.-파일-시스템)   

---
## 1. 운영체제의 개요

### (1) 운영체제 정의

* 사용자에게 편리한 인터페이스 환경을 제공하고 컴퓨터 시스템의 자원을 효울적으로 관리하는 소프트웨어

### (2) 운영체제 역할

#### 자원관리 ( 목표 : 효율성 )
* 컴퓨터 자원 배분 및 회수
#### 자원보호 ( 목표 : 안정성 )
* 비정상적인 작업으로부터 자원 보호
#### 하드웨어 인터페이스 제공 ( 목표 : 확장성 )
* 다양한 하드웨어 장치를 사용할 수 있도록 인터페이스 제공
#### 사용자 인터페이스 제공 ( 목표 : 편리성 )
* 사용자가 운영체제를 편리하게 사용할 수 있도록 지원

### (3) 운영체제 구조

#### 커널
* 프로세스 관리, 메모리 관리, 저장장치 관리와 같은 핵심적인 기능을 모아놓은 것
* 프로세스 관리 : 프로세스에 CPU를 배분하고 작업에 필요한 제반 환경 제공
* 메모리 관리 : 프로세스에 작업 공간을 배치하고 실제 메모리보다 큰 가상공간 제공
* 파일 시스템 관리 : 데이터를 저장하고 접근할 수 있는 인터페이스 제공
* 입출력 관리 : 필요한 입력과 출력 서비스 제공
* 프로세스 간 통신 관리 : 공동 작업을 위한 각 프로세스 간 통신 환경 지원

#### 시스템 호출
* 사용자나 응용 프로그램으로부터 컴퓨터 자원을 보호하기 위해 자원에 직접 접근하는 것을 차단하고 보호하기 위해 만든 인터페이스

#### 드라이버
* 운영체제가 많은 하드웨어를 모두 사용할 수 있는 환경을 제공할 수는 없기에, 커널은 입출력의 기본적인 부분만 제공하고 하드웨어의 특성을 반영한 소프트웨어는 디바이스 드라이버의 형태로 커널이 실행될 때 함께 실행

#### 인터페이스
* 사용자와 응용 프로그램에 인접하여 커널에 명령을 전달하고 실행 결과를 사용자와 응옹 프로그램에 돌려주는 역할

---
## 2. 프로세스와 스레드

### (1) 프로세스 개념
* 실행 중인 프로그램

### (2) 프로세스 상태
* 생성 : 프로세스가 메모리에 올라와 실행 준비를 완료한 상태, 프로세스 제어 블록(PCB) 생성
* 준비 : 생성된 프로세스가 CPU에 올라갈 때까지 기다리는 상태
* 실행 : CPU에 올라가 실제 작업을 수행하는 상태
* 완료 : 프로세스가 종료된 상태. 프로세스 제어 블록(PCB) 삭제
* 대기 : 실행 상태에 있는 프로세스가 입출력을 요청하면 입출력이 완료될 때까지 기다리는 상태. 입출력이 완료되면 준비 상태로 간다.

### (3) 프로세스 제어 블록(PCB)
* 프로세스를 실행하는 데 필요한 중요한 정보를 보관하는 자료 구조
* 포인터 : 프로세스 제어 블록의 첫 번째 블록에 위치하여 프로세스 제어 블록을 연결하여 준비상태나 대기상태의 큐를 구현하기 위한 것
* 프로세스 상태 : 프로세스가 현재 어떤 상태에 있는지를 나타내는 것
* 프로세스 구분자 : 운영체제 내에 있는 여러 프로세스를 구별하기 위한 구분자
* 프로그램 카운터 : 다음에 실행될 명령어의 위치를 가리키는 것
* 프로세스 우선순위 : CPU스케줄러가 준비상태 또는 대기상태에 있는 프로세스 중 실행 상태로 옮겨야 할 프로세스를 선택할 때 기준
* 각종 레지스터 정보 : 누산기, 색인 레지스터, 스택 포인터와 같은 이전에 실행할 때 사용한 레지스터의 값을 보관
* 메모리 관리 정보 : 프로세스가 메모리상의 위치 정보, 경계 레지스터값, 한계 레지스터 값 등을 저장
* 할당된 자원 정보 : 프로세스를 실행하기 위해 사용하는 입출력 자원이나 오픈 파일 등에 대한 정보
* 계정 정보 : 계정정보, CPU할당시간, CPU 사용시간 등을 저장
* 부모 프로세스 구분자와 자식 프로세스 구분자 : 부모, 자식 프로세스의 구분자(PID) 저장

### (4) 프로세스 구조
* 코드 영역 : 프로그램의 본문이 기술된 영역, 읽기 전용
* 데이터 영역 : 코드가 실행되면서 사용하는 변수나 파일 등의 각종 데이터를 모아놓은 곳, 읽기/쓰기
* 스택 영역 : 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳

### (5) 스레드 개념
* 프로세스의 코드에 정의된 절차에 따라 CPU에 작업 요청을 하는 실행 단위

### (6) 멀티스레드 개념
* 프로세스 내 작업을 여러 개의 스레드로 분할함으로써 작업의 부담을 줄이는 프로세스 운영 기법

### (7) 멀티스레드 장단점
#### 장점
* 응답성 향상 : 한 스레드가 입출력으로 인해 작업이 진행되지 않더라도, 다른 스레드가 작업을 계속하여 사용자의 작업 요구에 빠르게 응답
* 자원 공유 : 한 프로세스 내에서 독립적인 스레드를 생성하면 프로세스가 가진 자원을 모든 스레드가 공유하게 되어 작업을 원할하게 진행
* 효율성 향상 : 불필요한 자원의 중복을 막음으로써 시스템의 효율 향상 
* 다중 CPU 지원 : 2개 이상의 CPU를 가진 컴퓨터에서 멀티스레드를 사용하면 다중 CPU가 멀티스레드를 동시에 처리하여 CPU 사용량이 증가하고 프로세스의 처리 시간 단축
#### 단점
* 모든 스레드가 자원을 공유하기 떄문에 한 스레드에 문제가 생기면 전체 프로세스에 영향을 미친다.

### 연습문제
1. 프로그램이 프로세스가 되려면 운영체제로부터 무엇을 받아야 하는가?
* 프로세스 제어 블록(PCB)
2. 프로세스의 상태중 CPU를 할당받기 위해 기다리는 상태는 무엇인가?
* 준비 상태
3. 프로세스의 상태 중 입출력 작업을 하기 위해 이동하는 상태는 무엇인가?
* 대기 상태
4. CPU스케줄러가 준비상태에 있는 프로세스 중 하나를 골라 CPU를 할당하는 작업을 무엇이라고 하는가?
* 디스패치
5. 유닉스에서 CTRL+Z 키를 눌러 프로세스가 중단되면 프로세스는 어떤 상태로 바뀌는가?
* 휴식 상태
6. 실행 상태에서 하나의 프로세스가 나가고 새로운 프로세스가 들어오는 상황을 무엇이라고 하는가?
* 문맥 교환
7. 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 시스템 호출은 무엇인가?
* fork()
8. 프로세스의 골격은 그대로 둔 채 코드 영역만 바꾸는 시스템 호출은 무엇인가?
* exec()
9. 부모 프로세스가 기다리지 않아 자원이 회수되지 못하고 계속 살아 있는 프로세스는 무엇인가?
* 고아 프로세스
10. 프로세스의 코드에 정의된 절차에 따라 CPU에 작업 요청을 하는 실행 단위로서 가벼운 프로세스라고 불리는 것은 무엇인가?
* 스레드
11. 고아 프로세스를 방지하기 위해 부모 프로세스는 어떤 시스템 호출을 사용하는가?
* wait()
12. 작업이 끝난 프로세스의 자원을 회수하는 행위를 무엇이라고 하는가?
* Garbage collection
13. 모든 프로세스를 부모-자식 관계로 만들어 자원 회수를 용이하게 하는 프로세스의 구조는 무엇인가?
* 계층 구조

### 심화문제
1. 다섯 가지 프로세스 상태도를 그리시오.
* ![다운로드](https://user-images.githubusercontent.com/95995592/146670169-fb7ae22d-d67b-4f49-88db-a4897533724f.jpg)
2. 프로세스의 상태 중 휴식사앹와 보류상태에 대해 설명하시오.
* 휴식 상태 : 프로세스가 작업을 일시적으로 쉬고 있는 상태
* 보류 상태 : 프로세스가 메모리에서 잠시 쫓겨난 상태
3. 프로세스 제어 블록의 구성에 대해 설명하시오.
* 프로세스를 실행하는 데 필요한 중요한 정보를 보관하는 자료 구조
* 포인터 : 프로세스 제어 블록의 첫 번째 블록에 위치하여 프로세스 제어 블록을 연결하여 준비상태나 대기상태의 큐를 구현하기 위한 것
* 프로세스 상태 : 프로세스가 현재 어떤 상태에 있는지를 나타내는 것
* 프로세스 구분자 : 운영체제 내에 있는 여러 프로세스를 구별하기 위한 구분자
* 프로그램 카운터 : 다음에 실행될 명령어의 위치를 가리키는 것
* 프로세스 우선순위 : CPU스케줄러가 준비상태 또는 대기상태에 있는 프로세스 중 실행 상태로 옮겨야 할 프로세스를 선택할 때 기준
* 각종 레지스터 정보 : 누산기, 색인 레지스터, 스택 포인터와 같은 이전에 실행할 때 사용한 레지스터의 값을 보관
* 메모리 관리 정보 : 프로세스가 메모리상의 위치 정보, 경계 레지스터값, 한계 레지스터 값 등을 저장
* 할당된 자원 정보 : 프로세스를 실행하기 위해 사용하는 입출력 자원이나 오픈 파일 등에 대한 정보
* 계정 정보 : 계정정보, CPU할당시간, CPU 사용시간 등을 저장
* 부모 프로세스 구분자와 자식 프로세스 구분자 : 부모, 자식 프로세스의 구분자(PID) 저장
4. 문맥교환에 대해 설명하시오.
* CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업으로, 프로세스 제어 블록의 내용이 변경됨.
5. 프로세스를 구성하는 코드 영역, 데이터 영역, 스택 영역에 대해 설명하시오.
* 코드 영역 : 프로그램의 본문이 기술된 영역, 읽기 전용
* 데이터 영역 : 코드가 실행되면서 사용하는 변수나 파일 등의 각종 데이터를 모아놓은 곳, 읽기/쓰기
* 스택 영역 : 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳
6. fork() 시스템 호출의 장점을 설명하시오
* 기존 메모리에서 복사하는 구조로 프로세스의 생성 속도가 빠르다.
* 추가 자원 작업 없이 자원을 상속할 수 있다.
* 부모, 자식 프로세스 구분자로 연결되어 있음으로 정리를 부모 프로세스에 맡김으로써 시스템 관리를 효율적으로 할 수 있다.
7. exec() 시스템 호출을 사용하는 이유를 설명하시오.
* 프로세스의 구조체를 재활용함으로써, PCB, 메모리 영역, 부모-자식 관계를 그대로 사용할 수 있음으로 운영체제의 작업이 수월하다.
8. 프로세스 계층 구조의 장점을 설명하시오
* 동시에 여러 작업을 처리하고, 종료된 프로세스의 자원을 회수하는데 유용하다.
9. 멀티스레드, 멀티태스킹, 멀티프로세싱, CPU멀티스레드를 비교하여 설명하시오.
* 멀티스레드 : 프로세스 내 작업을 여러 개의 스레드로 분할함으로써 작업의 부담을 줄이는 프로세스 운영 기법
* 멀티태스킹 : 운영체제가 CPU에 작업을 줄 때 시간을 잘게 나누어(타임퀀텀) 배분하여, 여러 프로세스가 동시에 작업하는 것 처럼 보이게 배분하는 기법
* 멀티프로세싱 : CPU를 여러 개 사용하여 여러 개의 스레드를 동시에 처리하는 작업 환경
* CPU 멀티스레드 : 한 번에 하나씩 처리해야 하는 스레드를 파이프라인 기법을 이용하여 동시에 여러 스레드를 처리하도록 만든 병렬 처리 기법

---

## 3. CPU 스케줄링

### (1) CPU 스케줄링
  * 메모리에 올라온 프로세스들중 어떤 프로세스를 먼저 처리할지 일들의 순서를 정하는 것

### (2) 스케줄링 단계
  * 고수준 스케줄링 : 시스템 내의 전체 작업 수를 조절
  * 저수준 스케줄링 : 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 등을 결정
  * 중간 수준 스케줄링 : 중지와 활성화로 전체 시스템의 활성화된 프로세스 수를 조절하여 과부하 방지

### (3) 스케줄링 목적
  * 공평성 : 모든 프로세스가 자원을 공평하게 배정받아야 하며, 자원 배정 과정에서 특정 프로세스가 배제되어서는 안 된다.
  * 효율성 : 시스템 자원이 유휴 시간 없이 사용되도록 스케줄링 하고, 유휴 자원을 사용하려는 프로세스에는 우선권을 주어야 한다.
  * 안정성 : 우선순위를 사용하여 중요 프로세스가 먼저 작동하도록 배정함으로써 시스템 자원을 점유하거나 파괴하려는 프로세스로부터 자원 보호
  * 확장성 : 프로세스가 증가해도 시스템이 안정적으로 작동하도록 조치
  * 반응 시간 보장 : 적절한 시간 안에 프로세스의 요구에 반응
  * 무한 연기 방지 : 특정 프로세스의 작업이 무한히 연기되는 것을 방지

### (4) 스케줄링 시 고려 사항
  1. 선점형 스케줄링과 비선점형 스케줄링
    * 선점형 : 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 방식
      * 장점 : 프로세스가 CPU를 독점할 수 없어 대화형이나 시분할 시스템에 적합
      * 단점 : 문맥 교환의 오버헤드가 많다
    * 비선점형 : 어떤 프로세스가 CPU를 점유하면 다른 프로세스가 이를 빼앗을 수 없는 스케줄링 방식
      * 장점 : CPU 스케줄러의 작업량이 적고 문맥 교환의 오버헤드가 적다
      * 단점 : 기다리는 프로세스가 많아 처리율이 떨어진다
  2. 프로세스 우선순위 
    * 커널 프로세스
    * 일반 프로세스 
  3. CPU 집중 프로세스와 입출력 집중 프로세스
    * CPU 집중 : 수학 연산과 같이 CPU를 많이 사용하는 프로세스
    * 입출력 집중 : 저장장치에서 데이터를 복사하는 일과 같이 입출력을 많이 사용하는 프로세스
    * 입출력 집중 프로세스가 실행 상태로 가면 입출력 요구에 의해 대기 상태로 옮겨지기 때문에 다른 프로세스가 CPU를 사용할 수 있으므로, 입출력 집중 프로세스를 먼저 실행 상태로 옮기는 것이 효율적이다.
  4. 전면 프로세스와 후면 프로세스
    * 전면 프로세스(상호작용 프로세스)
      * GUI를 사용하는 운영체제에서 화면의 맨 앞에 놓인 프로세스 현재 입력과 출력을 사용하는 프로세스
    * 후면 프로세스(일괄 작업 프로세스)
      * 사용자와 상호작용이 없는 프로세스

### (5) 다중 큐
  1. 준비 상태의 다중 큐
    * 준비 상태에 들어올 때마다 자신의 우선순위에 해당하는 큐의 마지막에 삽입
    * 고정 우선순위 방식 
      * 운영체제가 프로세스에 우선순위를 부여하면 프로세스가 끝날 때까지 바뀌지 않는 방식
      * 시스템의 상황이 시시각각 변하는데 우선순위를 고정하면 시스템의 변화에 대응하기 어려워 작업 효율이 떨어짐
    * 변동 수선순위 방식
      * 프로세스 생성 시 부여받은 우선순위가 프로세스 작업 중간에 변하는 방식
      * 구현하기 어렵지만, 시스템의 효율성을 높일 수 있음
  2. 대기 상태의 다중 큐
    * 같은 입출력을 요구한 프로세스끼리 모아놓은 다중 큐
    * 입출력이 동시에 끝날 경우 여러 개의 인터럽트가 한꺼번에 처리됨으로, 인터럽트 벡터라는 자료구조를 이용

### (6) 스케줄링 알고리즘
  1. 스케줄링 알고리즘의 선택 기준
    * CPU 사용률 : 전체 시스템의 동작 시간 중 CPU가 사용된 시간
    * 처리량 : 단위 시간당 작업을 마친 프로세스의 수
    * 대기 시간 : 작업을 요청한 프로세스가 작업을 시작하기 전까지 대기하는 시간
    * 응답 시간 : 프로세스 시작 후 첫 번째 출력 또는 반응이 나올 때까지 걸리는 시간
    * 반환 시간 : 프로세스가 생성된 후 종료되어 사용하던 자원을 모두 반환하는 데까지 걸리는 시간
  2. FCFS 스케줄링
    * 준비 큐에 도착한 순선대로 CPU를 할당하는 비선점형 방식
  3. SJF 스케줄링
    * 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 방식
  4. HRN 스케줄링
    * 최고 응답률 우선 스케줄링
    * 우선순위 : ( 대기시간 + CPU 사용시간 ) / CPU 사용 시간
  5. 라운드 로빈 스케줄링
    * 한 프로세스가 할당받은 시간동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식
    * 타임 슬라이스를 너무 작게 설정하면 문맥 교환이 너무 자주 일어나서 시스템의 전반적인 성능이 떨어진다.
  6. SRT 우선 스케줄링
    * 최소 잔류 시간 우선 스케줄링
    * 남은 시간을 주기적으로 계산하고, 남은 시간이 더 적은 프로세스와 문맥교환을 해야 하므로 추가 작업이 필요
  7. 우선순위 스케줄링
    * 우선순위를 반영한 스케줄링
  8. 다단계 큐 스케줄링
    * 우선순위에 따라 준비 큐를 여러개 사용하는 방식
    * 고정형 우선순위
  9. 다단계 피드백 큐 스케줄링
    * CPU를 사용하고 난 프로세스의 우선순위가 낮아지는 방식의 다단계 큐 스케줄링
    * 마지막 큐는 타임 슬라이스를 무한대로 해서 FCFS 스케줄링 방식

### (7) 인터럽트
  * 개념
    * 입출력 하드웨어 등의 장치에 예외상황이 발생하여 처리가 필요할 경우에 CPU에 알려 처리할 수 있도록 하는 것
  * 동기적 인터럽트 : 프로세스가 실행 중인 명령어로 인해 발생
    * 프로그램상의 문제 때문에 발생하는 인터럽트
    * 컴퓨터 작업자가 의도적으로 프로세스를 중단하기 위해 발생시킨 인터럽트
    * 입출력장치 같은 주변장치의 조작에 의한 인터럽트
    * 산술 연산 중 발생하는 인터럽트
  * 비동기적 인터럽트 : 하드디스크 읽기 오류, 메모리 불량과 같은 하드웨어적인 오류로 발생
  * 인터럽트 처리 과정
    1. 현재 실행 중인 프로세스는 일시 정지 상태
    2. 인터럽트 컨트롤러가 실행되어 인터럽트의 처리 순서를 결정
    3. 인터럽트 벡터에 등록된 인터럽트 핸들러 실행
    4. 인터럽트 처리를 마치면 일시 정지된 프로세스가 다시 실행되거나 종료


### 연습문제
 1. 시스템 내 전체 프로세스의 수를 조절하는 것으로, 장기 스케줄링 또는 작업 스케줄링이라 불리는 스케줄링 수준은 무엇인가?
  * 고수준 스케줄링
 2. 어떤 프로세스에 CPU를 할당하고 어떤 프로세스를 대기 상태로 보낼지 등을 결정하는 스케줄링 수준은 무엇인가?
  * 저수준 스케줄링
 3. 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 스케줄링은 무엇인가?
  * 선점형 스케줄링
 4. 현재 입출력을 진행하는 프로세스로, 사용자와 상호작용이 가능하여 상호작용 프로세스라고도 불리는 것은 무엇인가?
  * 전면 프로세스
 5. 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 스케줄링 알고리즘은 무엇인가?
  * FCFS 스케줄링
 6. 준비 큐에 있는 프로세스 중 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 스케줄링 알고리즘은 무엇인가?
  * SJF 스케줄링
 7. SJF 스케줄링 알고리즘의 단점으로 크기가 큰 작업이 계속 뒤로 밀리는 현상을 무엇이라 하는가?
  * 아사 현상
 8. 아사 현상을 해결하는 방법을 설명하시오.
  * 에이징 : 프로세스가 양보할 수 있는 상한선을 정하는 방식
 9. 서비스를 받기 위해 대기한 시간과 CPU 사용 시간을 고려하여 우선순위를 정하는 스케줄링 알고리즘은 무엇인가?
  * HRN 스케줄링
 10. 프로세스가 할당받은 시간(타임 슬라이스)동안 작업하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 다음 자기 차례가 올 때까지 기다리는 선점형 스케줄링 알고리즘 중 가장 단순한 것은 무엇인가?
  * 라운드 로빈 스케줄링
 11. 타임 슬라이스의 크기와 문맥 교환의 관계를 설명하시오.
  * 타임 슬라이스를 너무 작게 설정하면 문맥 교환이 너무 자주 일어나 문맥 교환에 걸리는 시간이 실제 작업 시간보다 상대적으로 커지며, 문맥 교환에 많은 시간을 낭비하여 실제 작업을 못하는 문제가 발생
 12. 기본적으로 라운드 로빈 방식을 사용하지만, CPU를 할당받을 프로세스를 선택할 때 남아있는 작업 시간이 가장 적은 것을 선택하는 스케줄링 알고리즘은 무엇인가?
  * SRT 우선 스케줄링
 13. 우선순위에 따라 준비 큐를 여러 개 사용하며 고정형 우선순위를 적용하는 스케줄링 알고리즘은 무엇인가?
  * 우선순위 스케줄링
 14. 우선순위에 따라 준비 큐를 여러 개 사용하며, 프로세스가 CPU를 사용한 후 우선순위가 낮아지는 특징을 가진 스케줄링 알고리즘은 무엇인가?
  * 다단계 피드백 큐 스케줄링
 15. 다단계 피드백 큐 스케줄링에서 마지막 큐에 있는 프로세스(우선순위가 가장 낮은 프로세스)의 타임 슬라이스 크기는 얼마인가?
  * 무한대
 16. 다단계 피드백 큐 스케줄링에서 우선순위가 낮아질수록 타임 슬라이스의 크기는 어떻게 변하는가?
  * 우선순위가 낮아질수록 해당 큐의 타임 슬라이스가 커진다.
 17. 다단계 피드백 큐 스케줄링에서 마지막 큐(우선순위가 가장 낮은 큐)는 어떤 스케줄링 알고리즘처럼 동작하는가?
  * FCFS 스케줄링

### 심화문제
 1. 스케줄링의 단계와 그 특징을 설명하시오.
  * 고수준 스케줄링 : 시스템 내의 전체 작업 수를 조절
  * 저수준 스케줄링 : 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 등을 결정
  * 중간 수준 스케줄링 : 중지와 활성화로 전체 시스템의 활성화된 프로세스 수를 조절하여 과부하 방지 
 2. 스케줄링의 목적을 설명하시오.
  * 공평성 : 모든 프로세스가 자원을 공평하게 배정받아야 하며, 자원 배정 과정에서 특정 프로세스가 배제되어서는 안 된다.
  * 효율성 : 시스템 자원이 유휴 시간 없이 사용되도록 스케줄링 하고, 유휴 자원을 사용하려는 프로세스에는 우선권을 주어야 한다.
  * 안정성 : 우선순위를 사용하여 중요 프로세스가 먼저 작동하도록 배정함으로써 시스템 자원을 점유하거나 파괴하려는 프로세스로부터 자원 보호
  * 확장성 : 프로세스가 증가해도 시스템이 안정적으로 작동하도록 조치
  * 반응 시간 보장 : 적절한 시간 안에 프로세스의 요구에 반응
  * 무한 연기 방지 : 특정 프로세스의 작업이 무한히 연기되는 것을 방지
 3. 선점형 스케줄링과 비선점형 스케줄링을 비교하여 설명하시오.
  * 선점형 : 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 방식
    * 장점 : 프로세스가 CPU를 독점할 수 없어 대화형이나 시분할 시스템에 적합
    * 단점 : 문맥 교환의 오버헤드가 많다
  * 비선점형 : 어떤 프로세스가 CPU를 점유하면 다른 프로세스가 이를 빼앗을 수 없는 스케줄링 방식
    * 장점 : CPU 스케줄러의 작업량이 적고 문맥 교환의 오버헤드가 적다
    * 단점 : 기다리는 프로세스가 많아 처리율이 떨어진다
 4. 스케줄링 알고리즘의 선택 기준에 대해 설명하시오.
  * CPU 사용률 : 전체 시스템의 동작 시간 중 CPU가 사용된 시간
  * 처리량 : 단위 시간당 작업을 마친 프로세스의 수
  * 대기 시간 : 작업을 요청한 프로세스가 작업을 시작하기 전까지 대기하는 시간
  * 응답 시간 : 프로세스 시작 후 첫 번째 출력 또는 반응이 나올 때까지 걸리는 시간
  * 반환 시간 : 프로세스가 생성된 후 종료되어 사용하던 자원을 모두 반환하는 데까지 걸리는 시간
 5. FCFS, SJF, HRN 스케줄링의 특징을 설명하시오
  * FCFS 스케줄링
    * 준비 큐에 도착한 순선대로 CPU를 할당하는 비선점형 방식
  * SJF 스케줄링
    * 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 방식
  * HRN 스케줄링
    * 최고 응답률 우선 스케줄링
    * 우선순위 : ( 대기시간 + CPU 사용시간 ) / CPU 사용 시간
 6. 라운드 로빈, SRT, 다단계 큐, 다단계 피드백 큐 스케줄링의 특징을 설명하시오.
  * 라운드 로빈 스케줄링
    * 한 프로세스가 할당받은 시간동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식
    * 타임 슬라이스를 너무 작게 설정하면 문맥 교환이 너무 자주 일어나서 시스템의 전반적인 성능이 떨어진다.
  * SRT 우선 스케줄링
    * 최소 잔류 시간 우선 스케줄링
    * 남은 시간을 주기적으로 계산하고, 남은 시간이 더 적은 프로세스와 문맥교환을 해야 하므로 추가 작업이 필요
  * 다단계 큐 스케줄링
    * 우선순위에 따라 준비 큐를 여러개 사용하는 방식
    * 고정형 우선순위
  * 다단계 피드백 큐 스케줄링
    * CPU를 사용하고 난 프로세스의 우선순위가 낮아지는 방식의 다단계 큐 스케줄링
    * 마지막 큐는 타임 슬라이스를 무한대로 해서 FCFS 스케줄링 방식 
 7. 아사 현상과 에이징에 대해 설명하시오.
  *  아사 현상 : 특정 프로세스가 다른 프로세스에 밀려 CPU를 사용하지 못하고 계속해서 뒤로 밀리는 현상
  *  에이징 : 프로세스가 양보할 수 있는 상한선을 정하는 방식 
 8. 타임 슬라이스의 크기를 정하는 것과 시스템 효율성에 대해 설명하시오
  * 타임 슬라이스가 큰 경우 : 하나의 작업이 끝난 뒤, 다음 작업이 사직되는 것처럼 보인다.
  * 타임 슬라이스가 작은 경우 : 타임 슬라이스를 너무 작게 설정하면 문맥 교환이 너무 자주 일어나 문맥 교환에 걸리는 시간이 실제 작업 시간보다 상대적으로 커지며, 문맥 교환에 많은 시간을 낭비하여 실제 작업을 못하는 문제가 발생
---

## 4. 프로세스 동기화

### (1) 프로세스 간 통신
 * 프로세스가 다른 프로세스와 데이터를 주고받는 프로세스 간 통신에는 네트워크로 연결된 다른 컴퓨터에 있는 프로세스와의 통신도 포함
 * 프로세스 간 통신의 종류
 	* 프로세스 내부 데이터 통신 : 하나의 프로세스 내에 2개 이상의 스레드가 종재하는 경우의 통신, 전역 변수나 파일을 이용
 	* 프로세스 간 데이터 통신 : 같은 컴퓨터에 있는 여러 프로세스끼리 통신, 공용 파일 또는 운영체제가 제공하는 파이프 사용
 	* 네트워크를 이용한 데이터 통신 :  여러 컴퓨터가 네트워크로 연결되어 있을 때도 가능한 통신, 소켓을 이용
 * 프로세스 간 통신의 분류
 	* 통신 방향에 따른 분류
 		* 방향 통신 : 데이터를 동시에 양쪽 방향으로 전송할 수 있는 구조, 소켓
 		* 반양방향 통신 : 데이터를 양쪽 방향으로 전송할 수 있지만 동시 전송은 불가능하고 특정 시점에 한쪽 방향으로만 전송, 무전기
 		* 단방향 통신 : 한쪽 방향으로만 데이터를 전송, 전역변수나 파이프
 	* 통신 구현 방식에 따른 분류
 		* 대기가 있는 통신 : 동기화를 지원하는 방식, 데이터를 받는 쪽은 데이터가 도착할 때까지 자동으로 대기 상태에 머문다.
 		* 대기가 없는 통신 : 동기화를 지원하지 않는 방식, 데이터를 받는 쪽은 바쁜 대기를 사용하여 데이터가 도착했는지 여부를 직접 확인

### (2) 공유 자원
  * 여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일 등

### (3) 임계구역
  * 개념 : 자원접근 순서에따라 실행 결과가 달라지는 프로그램의 영역
  * 해결 조건
    - 상호 배제 : 한 프로세스가 임계구역에 들어가면 다른 프로세스는 임계구역에 들어갈 수 없다.
    - 한정 대기 : 어떤 프로세스도 무한 대기하지 않아야 한다.
    - 진행의 융통성 : 한 프로세스가 다른 프로세스의 진행을 방해해서는 안 된다.
  * 세마포어 : 임계구역에 진입하기 전에 스위치를 사용 중으로 놓고 임계구역으로 들어가는 방법
  * 모니터 : 보호할 자원을 임계구역으로 숨기고 임계구역에서 작업할 수 있는 인터페이스만 제공하여 세마포어 알고리즘을 자동으로 처리하도록 설계함으로써 자원을 보호

### 연습문제
 1. 프로세스 간 통신에서 데이터를 양방향으로 전송 가능하지만 동시 전송은 불가능하고 특정 시점에 한쪽 방향으로만 전송할 수 있는 통신 방식은 무엇인가?
  - 반양방향 통신
 2. 상태 변화를 살펴보기 위해 반복문을 무한 실행하며 기다리는 것을 무엇이라 하는가?
  - 바쁜 대기
 3. 프로세스 간 통신에서 대기가 없는 통신과 대기가 있는 통신의 예를 각각 제시하시오.
  - 대기가 있는 통신 : 동기화를 지원하는 방식, 데이터를 받는 쪽은 데이터가 도착할 때까지 자동으로 대기 상태에 머문다. / 파이프, 소켓
  - 대기가 없는 통신 : 동기화를 지원하지 않는 방식, 데이터를 받는 쪽은 바쁜 대기를 사용하여 데이터가 도착했는지 여부를 직접 확인 / 전역 변수, 파일
 4. 파이프를 이용하여 통신할 때 파이프를 2개 사용하는 이유는 무엇인가?
  - 파이프를 이용한 통신은 단방향 통신이므로, 양방향 통신을 위해 2개 사용
 5. 공유 자원을 병행적으로 읽거나 쓰는 상황을 무엇이라 하는가?
  - 경쟁 조건
 6. 공유 자원의 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역은 무엇인가?
  - 임계구역
 7. 임계구역 해결 조건 중 한 프로세스가 임계구역에 들어갔을 때 다른 프로세스는 임계구역에 들어갈 수 없는 조건을 무엇이라 하는가?
  - 상호 배제
 8. 임계구역 해결 조건 중 한 프로세스가 다른 프로세스의 진행을 방해해서는 안 된다는 조건을 무엇이라 하는가?
  - 진행의 융통성
 9. 임계구역 문제를 하드웨어적으로 해결한 방식으로, 하드웨어의 지원을 받아 명령어를 실행하는 도중에 타임아웃이 걸리지 않도록 하는 방식을 무엇이라 하는가?
  - 검사와 지정 코드
 10. 세마포어의 Semaphore(n)에서 n은 무엇을 가르키는가?
  - 공유 가능한 자원의 수
 11. 세마포어에서 내부 변수를 RS라고 할 때 세아포어 P()의 내부 코드를 쓰시오
  - if RS>0 then RS = RS-1; else block();
 12. 세마포어에서 내부 변수를 RS라고 할 때 세아포어 V()의 내부 코드를 쓰시오
  - RS=RS+1; wake_up();
 13. 세마포어가 제대로 작동하지 않는 경우를 설명하시오
  - 프로세스가 세마포어를 사용하지 않고 바로 임계구역으로 들어간 경우
  - P()를 두 번 사용하여 wake_up 신호가 발생하지 않은 경우
  - P(), V()를 반대로 사용하여 상호 배제가 보장되지 않은 경우
 14. 세마포어의 내부 코드도 타임아웃이 걸리면 문제가 발생할 수도 있다. 그래서 내부 코드는 무엇으로 보호받는가?
  - 검사와 지정
 15. 공유 자원을 내부적으로 숨기고 공유 자원에 접근하기 위한 인터페이스만 제공함으로써 자원을 보호하고 프로세스 간에 동기화를 시키는 것으로, 세마포어의 단점을 해결하면서 임계구역 문제를 해결한 방식은 무엇인가?
  - 모니터  

### 심화문제
 1. 프로세스 간 통신을 통신 방향에 따라 분류하여 설명하시오
  - 양방향 통신 : 데이터를 동시에 양쪽 방향으로 전송할 수 있는 구조, 소켓
  - 반양방향 통신 : 데이터를 양쪽 방향으로 전송할 수 있지만 동시 전송은 불가능하고 특정 시점에 한쪽 방향으로만 전송, 무전기
  - 단방향 통신 : 한쪽 방향으로만 데이터를 전송, 전역변수나 파이프
 2. 대기가 있는 통신과 대기가 없는 통신의 의미를 설명하고 적절한 예를 제시하시오
  - 대기가 있는 통신 : 동기화를 지원하는 방식, 데이터를 받는 쪽은 데이터가 도착할 때까지 자동으로 대기 상태에 머문다. / 파이프, 소켓
  - 대기가 없는 통신 : 동기화를 지원하지 않는 방식, 데이터를 받는 쪽은 바쁜 대기를 사용하여 데이터가 도착했는지 여부를 직접 확인 / 전역 변수, 파일 
 3. 실생활의 예를 들어 임계구역 문제를 설명하시오
  - 생산자는 계속 물건을 생산해서 원형 버퍼에 넣고, 소비자는 계속 원형 버퍼에서 물건을 가져올 때, 생산자가 물건을 넣고 총량을 증가시키기 전에 소비자가 총량을 차감하여 오류가 발생
 4. 다음 코드의 문제점을 설명하시오
  - 전역 변수로 잠금을 구현한 코드로, 전역 변수의 상태를 변화하는 순간 타임 아웃이 발생하여 다른 프로세스가 수행된다면 동시에 임계구역에 진입하게 된다.
 5. 다음 코드의 문제점을 설명하시오
  - 전역 변수로 상호 배제와 한정 대기 조건을 충족하는 코드로, 서로 번갈아가면서 수행하기 때문에 진행의 융통성 조건을 보장하지 못한다.
 6. 파일을 이용하여 Test라는 문자를 주고받는 코드를 작성하시오
  - ```C
    #include <studio.h>
    #include <unistd.h>
    #include <fcntl.h>
    
    void main()
    {
      int pid, fd;
      char buf[5];
      
      fd = open("com.txt",0_RDWR);
      pid = fork();
      
      if(pid<0 || fd<0)
      {
       exit(-1);
      }
      else if(pid == 0)
      {
       write(fd,"Test",5);
       close(fd);
       exit(0);
      }
      else
      {
       wait(0);
       lseek(fd,0,SEEK_SET);
       read(fd,buf,5);
       printf("%s",buf);
       close(fd);
       exit(0);
      }
      
    }

    ```
---

## 5. 교착 상태

### (1) 교착 상태의 개요
 * 2개 이상의 프로세스가 다른 프로세스의 작업이 끝나기만 기다리며 작업을 더 이상 진행하지 못하는 상태

### (2) 자원 할당 그래프
 * 프로세스가 어떤 자원을 사용 중이고, 어떤 자원을 기다리고 있는지를 방향성이 있는 그래프로 표현한 것

### (3) 교착 상태 필요 조건
 * 상호 배제 : 한 프로세스가 사용하는 자원은 다른 프로세스와 공유할 수 없는 배타적인 자원이어야 한다.
 * 비선점 : 한 프로세스가 사용 중인 자원은 중간에 다른 프로세스가 빼앗을 수 없는 비선점 자원이어야 한다.
 * 점유와 대기 : 프로세스가 어떤 자원을 할당받은 상태에서 다른 자원을 기다리는 상태
 * 원형 대기 : 점유와 대기를 하는 프로세스 간의 관계가 원을 이뤄야 한다.

### (4) 교착 상태 해결 방법
 1. 예방 : 교착 상태를 유발하는 네 가지 조건이 발생하지 않도록 무력화하는 방식
  * 상호 배제 예방 : 독점적으로 사용할 수 있는 자원을 없애버리는 방법
  * 비선점 예방 : 모든 자원을 빼앗을 수 있도록 만드는 방법, 아사현상 유발
  * 점유와 대기 예방 : 자원을 점유한 상태에서 다른 자원을 기다리지 못하게 하는 방법
  	* 프로세스가 자신이 사용하는 모든 자원을 자세히 알기 어렵다
  	* 자원의 활용성이 떨어진다.
  	* 많은 자원을 사용하는 프로세스가 적은 자원을 사용하는 프로세스보다 불리하다
  	* 일괄 작업 방식으로 동작 
  * 원형 대기 예방 : 자원을 한 방향으로만 사용하도록 설정하는 방법
  	* 유연성이 떨어진다.
  	* 자원의 번호를 어떻게 붙이든 자원 사용에 제약이 따른다. 
 2. 회피 : 자원 할당량을 조절하여 교착 상태를 해결하는 방식
  * 자원의 총수와 현재 할당된 자원의 수를 기준으로 시스템을 안정 상태, 불안정 상태로 나누고 안정 상태를 유지하도록 자원을 할당
  * 은행원 알고리즘
  	* 각 프로세스의 기대 자원과 가용 자원을 비교하여 기대 자원이 가용 자원보다 작은 경우, 자원을 할당한다.
  	* 전체 자원 : 시스템 내 전체 자원의 수
  	* 가용 자원 : 시스템 내 현재 사용할 수 있는 자원의 수 ( 가용자원 = 전체 자원 - 모든 프로세스의 할당 자원 ) 
  	* 최대 자원 : 각 프로세스가 선언한 치대 자원의 수
  	* 할당 자원 : 각 프로세스에 현재 할당된 자원의 수
  	* 기대 자원 : 각 프로세스가 앞으로 사용할 자원의 수 ( 기대 자원 = 최대 자원 - 할당 자원 )
  	* 단점
  		* 프로세스가 자신이 사용할 모든 자원을 미리 선언해야 한다.
  		* 시스템의 전체 자원 수가 고정적이어야 한다.
  		* 모든 불안정 상태가 교착 상태가 되는 것은 아님에도 불구하고 자원을 할당하지 않는 것은 자원 낭비이다.
 3. 검출과 회복 : 자원 할당 그래프를 모니터링하면서 교착 상태를 검출하고 회복시키는 방법
  1) 검출
   * 타임아웃 : 일정 시간 동안 작업이 진행되지 않은 프로세스를 교착상태가 발생한 것으로 간주하여 처리
				* 데이터 일관성이 깨지는 문제를 해결하기 위해 체크포인트, 롤백을 사용
						* 체크포인트 : 작업을 하다가 문제가 발생하면 저장된 상태로 되돌아오기 위한 표식  
						* 스냅숏 : 체크포인트 설정 시 현재의 시스템 상태를 저장한 데이터
						* 롤백 : 과거의 체크포인트로 되돌아가는 것
   	* 단점
   		* 엉뚱한 프로세스가 강제 종료될 수 있다.
   		* 분산 시스템의 경우, 원격지에 있는 프로세스의 응답이 없는 것이 교착 상태 때문인지 네트워크 문제인지 정확히 알 수 없으므로 모든 시스템에 적용할 수 없다.  
   * 자원 할당 그래프 : 자원 할당 그래프를 사용해서 교착상태가 발생한 것을 검출하는 방법
  2) 회복
   * 교착 상태를 일으킨 모든 프로세스를 동시에 종료
   * 교착 상태를 일으킨 프로세스 중 하나를 골라 순서대로 종료
   	* 우선순위가 낮은 프로세스를 먼저 종료
   	* 우선순위가 같은 경우 작업 시간이 짧은 프로세스를 먼저 종료
   	* 위의 두 조건이 같은 경우 자원을 많이 사용하는 프로세스를 먼저 

### 연습문제
 1. 2개 이상의 프 로세스가 서로의 작업이 끝나기만 기다리며 작업을 더 이상 진행하지 못하는 상태를 무엇이라 하는가?
  - 교착 상태
 2. 프로세스가 어떤 자원을 사용 중이고 어떤 자원을 기다리고 있는지를 나타내는 방향성이 있는 그래프를 무엇이라 하는가?
  - 자원 할당 그래프
 3. 네 가지 교착 상태 필요조건에 대해 설명하시오.
  - 상호 배제 : 한 프로세스가 사용하는 자원은 다른 프로세스와 공유할 수 없는 배타적인 자원이어야 한다.
  - 비선점 : 한 프로세스가 사용 중인 자원은 중간에 다른 프로세스가 빼앗을 수 없는 비선점 자원이어야 한다.
  - 점유와 대기 : 프로세스가 어떤 자원을 할당받은 상태에서 다른 자원을 기다리는 상태
  - 원형 대기 : 점유와 대기를 하는 프로세스 간의 관계가 원을 이뤄야 한다.
 4. 교착 상태 해결 방법 중, 교착 상태를 유발하는 네 가지 조건을 무력화하는 방법은 무엇인가?
  - 교착 상태 예방
 5. 교착 상태 해결 방법 중, 교착 상태가 발생하지 않는 수준으로 자원을 할당하는 방법은 무엇인가?
  - 교착 상태 회피
 6. 교착 상태 해결 방법 중, 자원 할당 그래프를 사용하여 교착 상태를 발견하는 방법은 무엇인가?
  - 교착 상태 검출
 7. 교착 상태 해결 방법 중, 타임아웃을 이용하여 해결하는 방법은 무엇인가?
  - 교착 상태 검출
 8. 교착 상태 해결 방법 중, 은행원 알고리즘을 사용하여 해결하는 방법은 무엇인가?
  - 교착 상태 회피
 9. 교착 상태 해결 방법 중, 모든 자원에 번호를 부여하고 낮은 번호의 자원을 사용할 수 없도록 하는 방법은 무엇인가?
  - 교착 상태 예방 - 원형 대기 예방
 10. 교착 상태 해결 방법 중, 프로세스가 시작 초기에 자신이 사용하려는 모든 자원을 한꺼번에 점유하거나, 그렇지 못할 경우 자원을 모두 반납하는 방법은 무엇인가?
  - 교착 상태 예방 - 점유와 대기 예방
 11. 교착 상태 해결 방법 중, 교착 상태가 검출되면 교착 상태를 일으킨 모든 프로세스를 종료하는 방법은 무엇인가?
  - 교착 상태 회복
 12. 자원 할당 그래프에서 무엇이 발견되면 교착 상태라고 판단할 수 있는가?
  - 사이클

### 심화문제
 1. 교착 상태 해결 방법 중, 프로세스가 시작 초기에 자신이 사용하려는 모든 자원을 한꺼번에 점유하거나, 그렇지 못할 경우 자원을 모두 반납하는 방법이 있다. 이 방법의 단점을 설명하시오.
  - 프로세스가 자신이 사용하는 모든 자원을 자세히 알기 어렵다
  - 자원의 활용성이 떨어진다.
  - 많은 자원을 사용하는 프로세스가 적은 자원을 사용하는 프로세스보다 불리하다
  - 일괄 작업 방식으로 동작 
 2. 교착 상태 회피 방법인 은행원 알고리즘의 단점을 설명하시오.
  - 프로세스가 자신이 사용할 모든 자원을 미리 선언해야 한다.
  - 시스템의 전체 자원 수가 고정적이어야 한다.
  - 모든 불안정 상태가 교착 상태가 되는 것은 아님에도 불구하고 자원을 할당하지 않는 것은 자원 낭비이다.
 3. 교착 상태 검출 시 타임아웃을 이용하는 방법의 장단점을 설명하시오.
  - 단점
    + 엉뚱한 프로세스가 강제 종료될 수 있다.
    + 분산 시스템의 경우, 원격지에 있는 프로세스의 응답이 없는 것이 교착 상태 때문인지 네트워크 문제인지 정확히 알 수 없으므로 모든 시스템에 적용할 수 없다.  
  - 장점 : 특별한 알고리즘이 없어 쉽게 구현할 수 있다. 

---
## 6. 물리 메모리 관리

### (1) 컴파일러
* 정의
	- 소스코드를 컴퓨터가 실행할 수 있는 기계어로 번역한 후, 한꺼번에 실행한다. ( C, JAVA 등 )

* 목적
	- 오류 발견 : 심벌테이블을 사용하여 소스코드에서 오류를 발견하여 실행 시 문제가 없도록 하는 것
	- 코드 최적화 : 실행하기 전에 코드를 점검하여 오류를 수정하고 최적화함으로써 작고 빠른 실행 파일 생성 

* 과정
	- 1) 소스코드 작성 및 컴파일 : 소스코드를 작성후 일차로 번역하여 목적코드 생성
	- 2) 목적코드와 라이브러리 연결
	- 3) 동적 라이브러리를 포함하여 최송 실행 

### (2) 인터프리터
* 소스코드를 한 행씩 번역하여 실행한다. ( 자바스크립트, 베이직 등 )

### (3) 메모리 관리자
* 역할
	- 가져오기 : 프로세스와 데이터를 메모리로 가져오는 것, 메모리가 충분하지 않다면 필요한 것부터 수시로 가져와서 실행, 사용자의 요청이 없더라도 앞으로 필요할 것이라고 예상되는 데이터를 미리 가져오기도 한다.
	- 배치 : 가져온 프로세스와 데이터를 메모리의 어떤 부분에 올려놓을지 결정
	- 재배치 : 메모리가 꽉 찼을 경우, 메모리에 있는 프로세스를 하드디스크로 옮기고 새로운 프로세스를 메모리에 가져오기 위해 오래된 프로세스를 내보내는 작업
 
### (4) 메모리 주소
 * 물리 주소 공간 : 하드웨어 입장에서의 메모리의 주소 공간, 물리주소 0번지부터 시작 ( 절대 주소 )
 * 논리 주소 공간 : 사용자의 입장에서의 메모리의 주소 공간, 물리주소와 관계없이 항상 0번지부터 시작 ( 상대 주소 )

### (5) 단일 프로그래밍 환경에서의 메모리 할당
* 메모리 오버레이 : 프로그램의 크기가 실제 메모리보다 클 때 전체 프로그램을 메모리에 가져오는 대신 적당한 크기로 잘라서 가져오는 기법
* 스왑 영역 : 메모리가 모자라서 쫓겨난 프로세스들을 저장하는 저장장치 내 공간, 메모리 관리자가 관리

### (6) 다중 프로그래밍 환경에서의 메모리 할당

* 분할 방식
	-  가변 분할 방식 : 세그멘테이션, 프로세스의 크기에 따라 메모리를 나누는 것, 하나의 프로세스를 연속된 공간에 배치, 메모리 통합 작업이 필요하므로 관리가 복잡함 ( 17KB, 18KB가 나눠서 비었을 때 30KB를 할당하기 위해선 합쳐야함, 외부 단편화 )
	-  고정 분할 방식 : 페이징, 프로세스의 크기와 상관없이 메모리를 같은 크기로 나누는 것, 메모리 관리가 수월, 쓸모없는 공간으로 인해 메모리 낭비( 20KB 에 18KB 할당, 내부 단편화 )


* 배치 방식
	- 최초 배치 : 메모리에서 적재 가능한 공간 중 첫 번째에 배치하는 방법
	- 최적 배치 : 빈 공간을 모두 확인한 후, 적당한 크기 가운데 가장 작은 공간에 배치하는 방법  	
	- 최악 배치 : 빈 공간을 모두 확인한 후, 가장 큰 공간에 배치하는 방법

* 버디 시스템
	- 1) 프로세스의 크기에 맞게 메모리를 1/2로 나눠가면서 메모리에 배치
	- 2) 나뉜 메모리의 각 구역에는 프로세스가 1개만 들어간다.
	- 3) 프로세스가 종료되면 주변의 빈 조각과 합쳐서 하나의 큰 덩어리를 만든다
	- 장점 : 비슷한 크기의 덩어리가 서로 모여 있어서 통합하기가 쉽다.

### 연습문제
1. 소스코드를 한 번에 번역하지 않고 한 행씩 번역하여 실행하는 방식을 무엇이라 하는가?
	- 인터프리터
2. 프로그래머가 C나 자바로 소스코드를 작성하여 컴파일하면 일차적으로 만들어지는 코드는 무엇인가?
	- 목적 코드
3. 컴파일할 때 코드에 라이브러리를 연결하지 않고 코드를 실행할 때 라이브러리를 가져와 실행하는 방식을 무엇이라 하는가?
	- 동적 라이브러리
4. 메모리 관리 정책 중 메모리가 꽉 찼을 때 메모리에 있는 어떤 프로세스를 내보낼지 결정하는 것은 무엇인가?
	- 재배치 작업
5. 32bit CPU를 사용하는 컴퓨터가 가질 수 있는 물리 메모리의 최대 크기는 무엇인가?
	- 2^32B(약 4GB)
6. 절대 주소는 실제 물리 주소로, 메모리 관리자 입장에서 바라본 주소이다. 절대 주소와 관계없이 사용자 입장에서 항상 0번지부터 시작하는 주소는 무엇인가?
	- 상대 주소
7. 상대 주소를 절대 주소로 변환할 때 사용하는 레지스터는 무엇인가?
	- 재배치 레지스터
8. 프로세스의 크기가 물리 메모리보다 클 때 전체 프로세스를 메모리로 가져오는 대신 적당한 크기로 잘라서 가져오는 기법은 무엇인가?
	- 메모리 오버레이
9. 메모리 영역이 부족해서 쫓겨난 프로세스를 보관하는 저장장치의 특별한 공간은 무엇인가?
	- 스왑 영역
10. 가변 분할 방식에서 사용하지 못하는 작은 메모리 공간이 발생하는 현상을 무엇이라 하는가?
	- 외부 단편화
11. 고정 분할 방식에서 똑같이 나누어진 메모리 공간에 작은 조각이 발생하는 현상을 무엇이라 하는가?
	- 내부 단편화
12. 가변 분할 방식의 메모리 배치 방식 중 프로세스를 배치하기에 적당한 공간 가운데 가장 작은 공간에 배치하는 방식은 무엇인가?
	- 최적 배치
13. 가변 분할 방식의 메모리 배치 방식 중 첫 번째로 발견한 빈 공간에 프로세스를 배치하는 방식은 무엇인가?
	- 최초 배치
14. 가변 분할 방식의 메모리 배치 방식 중 가장 큰 공간에 프로세스를 배치하는 방식은 무엇인가?
	- 최악 배치
15. 가변 분할 방식에서 서로 떨어진 여러 개의 빈 공간을 합치는 작업을 무엇이라 하는가?
	- 조각 모음
16. 메모리 분할 방식 중 프로세스의 크기에 맞도록 1/2크기로 잘라가면서 메모리를 나누어주는 방식은 무엇인가?
	- 버디 시스템

### 심화문제	
1. 컴파일러와 인터프리터를 비교하여 설명하시오
	- 컴파일러 : 소스코드를 컴퓨터가 실행할 수 있는 기계어로 번역한 후, 한꺼번에 실행한다. ( C, JAVA 등 )
	- 소스코드를 한 행씩 번역하여 실행한다. ( 자바스크립트, 베이직 등 )
2. 컴파일 과정에 대해 설명하시오
	- 1) 소스코드 작성 및 컴파일 : 소스코드를 작성후 일차로 번역하여 목적코드 생성
	- 2) 목적코드와 라이브러리 연결
	- 3) 동적 라이브러리를 포함하여 최송 실행 
3. 메모리 관리자가 수행하는 세 가지 작업에 대해 설명하시오
	- 가져오기 : 프로세스와 데이터를 메모리로 가져오는 것, 메모리가 충분하지 않다면 필요한 것부터 수시로 가져와서 실행, 사용자의 요청이 없더라도 앞으로 필요할 것이라고 예상되는 데이터를 미리 가져오기도 한다.
	- 배치 : 가져온 프로세스와 데이터를 메모리의 어떤 부분에 올려놓을지 결정
	- 재배치 : 메모리가 꽉 찼을 경우, 메모리에 있는 프로세스를 하드디스크로 옮기고 새로운 프로세스를 메모리에 가져오기 위해 오래된 프로세스를 내보내는 작업
4. 절대 주소와 상대 주소에 대해 설명하시오
	- 물리 주소 공간 : 하드웨어 입장에서의 메모리의 주소 공간, 물리주소 0번지부터 시작 ( 절대 주소 )
 	- 논리 주소 공간 : 사용자의 입장에서의 메모리의 주소 공간, 물리주소와 관계없이 항상 0번지부터 시작 ( 상대 주소 )
5. 가변 분할 방식의 장단점을 설명하시오
	-  가변 분할 방식 : 세그멘테이션, 프로세스의 크기에 따라 메모리를 나누는 것, 하나의 프로세스를 연속된 공간에 배치, 메모리 통합 작업이 필요하므로 관리가 복잡함 ( 17KB, 18KB가 나눠서 비었을 때 30KB를 할당하기 위해선 합쳐야함, 외부 단편화 )
6. 고정 분할 방식의 장단점을 설명하시오
	-  고정 분할 방식 : 페이징, 프로세스의 크기와 상관없이 메모리를 같은 크기로 나누는 것, 메모리 관리가 수월, 쓸모없는 공간으로 인해 메모리 낭비( 20KB 에 18KB 할당, 내부 단편화 )
7. 버디 시스템에 대해 설명하시오
	- 1) 프로세스의 크기에 맞게 메모리를 1/2로 나눠가면서 메모리에 배치
	- 2) 나뉜 메모리의 각 구역에는 프로세스가 1개만 들어간다.
	- 3) 프로세스가 종료되면 주변의 빈 조각과 합쳐서 하나의 큰 덩어리를 만든다
	- 장점 : 비슷한 크기의 덩어리가 서로 모여 있어서 통합하기가 쉽다.

---
## 7. 가상 메모리의 기초

### (1) 가상메모리
- 물리 메모리의 크기와 상관없이 프로세스에 커다란 메모리 공간을 제공하는 기술
- 동적 주소 변환 : 가상 주소를 실제 메모리의 물리 주소로 변환
	
	
### (2) 페이징 기법
- 물리 주소 공간을 같은 크기로 나누어 사용, 프레임
- 페이지 테이블 : 가상주소의 각 페이지가 물리 메모리의 어디에 위치하는지를 나타내는 맵핑 정보 테이블, 물리 메모리상 운영체제 영역, 각 줄을 페이지 테이블 엔트리라고 부른다.
- 페이지 테이블 레지스터 : 각 프로세스가 각 페이지 테이블의 시작 주소를 보관하여, 빠르게 접근
- VA = <P,D> , PA = <F,D>
- 직접 맵핑 : 페이지 테이블 전체가 물리 메모리의 운영체제 영역에 존재하는 방식
- 연관 맵핑 : 페이지 테이블 전체를 스왑 영역에서 관리하는 방식, 페이지 테이블 일부(변환 색인 버퍼, 연관 레지스터)를 물리 메모리에 가져오는 방식
- 집합 연관 맵핑 : 연관 맵핑과 비슷하지만, 페이지 테이블을 일정한 집합으로 자르고, 자른 더어리 단위로 물리 메모리에 올리는 것, 집합 테이블로 해당 집합이 어디에 있는지 표시
- 역맵핑 : 프레임 번호를 기준으로 어떤 프로세스의 어떤 페이지가 올라와 있는지를 표시, 페이지 테이블의 크기는 작지만 모두 검색해야함
	
### (3) 세그멘테이션 기법
- 세그멘테이션 맵핑 테이블 : 세그먼트의 크기(limit), 물리 메모리상 시작주소(address)로 이뤄짐
- 물리 메모리의 외부 단편화로 인해 물리 메모리 관리가 복잡
- VA = <S,D>
- 메모리 접근 권한
	- 코드 영역 : 자기 자신을 수정하는 프로그램은 없기 때문에 읽기 및 실행 권한을 가진다.
	- 데이터 영역 : 읽거나 쓸 수 있수 있는 데이터(변수), 읽기만 가능한 데이터(상수)
	- 추가권한은 항상 쓰기 권한이 동반되어야 한다.
	- 가상주소에서 물리주소로 주소 변환이 일어날 때마다 접근 권한 검사 시행
- 세그멘테이션-페이징 혼용 기법
	- 페이지 테이블의 모든 행에 접근 권한과 관련된 권한 비트 추가
	- 가상 주소 공간에서 서로 관련있는 영역을 하나의 세그먼트로 묶어 세그멘테이션 테이블로 관리
	- 각 세그먼트를 구성하는 페이지를 해당 페이지 테이블로 관리
	- 각 세그멘테이션 테이블은 자신과 연결된 페이지 테이블의 시작 주소를 가진다.
	
### (4) 캐시 매핑 기법
- 캐시 직접 맵핑
	- 캐시를 일정 크기로 나눠서 관리하는 방법, 페이지
	- 메모리는 N개, 캐시는 M개의 페이지로 구성
	- N/M (Block) 단위로 메모리를 자른다.
	- 메모리의 블록이 캐시로 올라올 때 항상 같은 위치에 올라온다. 즉 블록의 첫 번째 페이지는 캐시의 첫 번째 페이지, 블록의 두 번째 페이지는 캐시의 두 번째 페이지
	- VA = <tag,bd,?

- 캐시 연관 맵핑
	- 캐시가 메모리 워드의 주소를 모두 가지고 있음
	- 캐시 히트, 미스를 확인하기 위해 캐시의 모든 주소를 검색해야 함

- 캐시 집합-연관 맵핑
	- 캐시를 k개의 집합으로 나누고, 각 집합에 직접 맵핑을 사용
		
### (5) 연습문제
1. 가상 메모리에서 메모리 관리자가 사용할 수 있는 전체 크기는 어떻게 결정되는가?
	- 물리 메모리 + 스왑 영역
2. 가상 주소에서 하나의 프로세스가 사용할 수 있는 최대 주소는 무엇과 연관이 있는가?
	- CPU 비트
3. 가상 메모리에서 가상 주소를 물리 주소로 변환하기 위해 사용하는 자료 구조를 무엇이라 하는가?
	- 매핑 테이블
4. 페이징 기법의 주소 변환 과정 식을 쓰시오.
	- VA = <P,D> -> PA = <F,D>
5. 페이지 테이블에서 각각의 한 줄을 무엇이라 쓰는가?
	- 페이지 테이블 엔트리
6. 가상 주소를 <P,D>로 변환하는 공식을 쓰시오.
	- P : [가상주소/페이지 크기] 의 몫
	- D : [가상주소/페이지 크기] 의 나머지
7. 각 페이지 테이블의 시작 주소를 가지고 있는 레지스터는 무엇인가?
	- PTBR
8. 페이지 테이블 매핑 방식 중, 모든 페이지 테이블을 스왑 영역에 저장하고 그중 일부만 물리 메모리에 무작위로 가지고 있는 방식은 무엇인가?
	- 연관 매핑
9. 페이지 테이블 매핑 방식 중, 모든 페이지 테이블을 물리 메모리에 보관하는 방식은 무엇인가?
	- 직접 매핑
10. 페이지 테이블 매핑 방식 중, 모든 페이지 테이블을 스왑 영역에 저장하고 페이지 테이블을 일정한 집합 단위로 물리 메모리에 보관하는 방식은 무엇인가?
	- 집합-연관 매핑
11. 페이지 테이블 매핑 방식 중, 물리 메모리의 프레임 번호를 기준으로 구성하는 방식은 무엇인가?
	- 역매핑
12. 연관 매핑에서 사용하는 테이블의 이름은 무엇인가?
	- 변환 색인 버퍼
13. 연관 매핑에서 원하는 데이터가 변환 색인 버퍼에 없는 상태를 무엇이라 하는가?
	- TBL 미스
14. 연관 매핑에서는 전체 매핑 테이블을 어디에 보관하는가?
	- 스왑 영역
15. 가상 메모리에서 메모리 관리자는 물리 메모리 영역과 스왑 영역을 합쳐서 프로세스가 사용하는 가상 주소를 실제 메모리의 물리 주소로 변환한다. 이러한 작업을 무엇이라 하는가?
	- 동적 주소 변환
16. 사용자 프로세스가 자신의 크기보다 더 큰 주소에 접근하려고 하면 메모리 관리자는 그 프로세스를 강제 종료한다. 이때 발생하는 오류를 무엇이라 하는가?
	- 트랩
17. 세그멘테이션-페이징 혼용 기법에서는 접근 권한을 어디에서 관리하는가?
	- 세그멘테이션 테이블

### (6) 심화 문제
1. 가상 메모리가 이론적으로 가질 수 있는 크기와 실제 운영되는 크기는 어떤 차이가 있는지 설명하시오.
	- 이론 : 스왑 영역을 사용함으로써, 무한대
	- 실제 : 물리 메모리의 최대 크기로 한정
2. 페이징 기법의 주소 변환 과정을 그림으로 그리고 설명하시오.
	![image](https://user-images.githubusercontent.com/95995592/149653542-4b720b50-5d1f-4170-9db9-cb8c0c3b90a8.png)

	- 가상 주소 31번지가 어느 페이지에 있는지 찾는다. 31번지는 페이지 3의 1번째 위치에 있다.
	- 페이지 테이블의 페이지 3으로 가서 해당 페이지가 프레임 1에 있다는 것을 알아낸다.
	- 프로세스가 저장하려는 값을 프레임 1의 1번 위치에 저장한다.
3. 연관 매핑의 동작을 설명하시오.
	- 페이지 테이블 전체를 스왑 영역에서 관리하는 방식, 페이지 테이블 일부(변환 색인 버퍼, 연관 레지스터)를 물리 메모리에 가져오는 방식
4. 집합-연관 매핑의 동작을 설명하시오.
	- 연관 맵핑과 비슷하지만, 페이지 테이블을 일정한 집합으로 자르고, 자른 더어리 단위로 물리 메모리에 올리는 것, 집합 테이블로 해당 집합이 어디에 있는지 표시
5. 역매핑의 동작을 설명하시오.
	- 프레임 번호를 기준으로 어떤 프로세스의 어떤 페이지가 올라와 있는지를 표시, 페이지 테이블의 크기는 작지만 모두 검색해야함
6. 세그멘테이션-페이징 혼용 기법을 사용하는 이유를 설명하시오.
	- 페이징 기법은 메모리 관리가 수월한 반면 페이지 테이블의 크기가 크고, 세기멘테이션 기법은 페이지테이블의 크기를 작게 유지하지만 물리 메모리의 외부 단편화로 인해 추가적인 관리가 필요하기 때문에, 페이징 기법에 세그멘테이션 테이블을 추가하고 권한 비트와 같이 중복되는 데이터를 세그멘테이션 테이블로 옮겨 오면 테이블의 크기를 줄일 수 있음. 

---

## 8. 가상 메모리 관리

### (1) 요구 페이징
* 사용자가 요구할 때 해당 페이지를 메모리로 가져오는 것
* 페이지 부재 : 페이지를 요청했을 때, 그 페이지가 메모리에 없는 상황
* 페이지 교체 알고리즘 : 빈 프레임이 없을 때 메모리에 있는 프레임 중 어떤 것을 스왑 영역으로 내보낼지 결정하는 알고리즘
* 대상 페이지 : 페이지 교체 알고리즘에 의해 스왑 영역으로 보낼 페이지
	
### (2) 지역성
* 기억장치에 접근하는 패턴이 메모리 전체에 고루 분포되는 것이 아니라 특정 영역에 집중되는 성질
* 공간의 지역성 : 현재 위치에서 가까운 데이터에 접근할 확률이 먼 거리에 있는 데이터에 접근할 확률보다 높다는 것
* 시간의 지역성 : 현재를 기준으로 가장 가까운 시간에 접근한 데이터가 더 먼 시간에 접근한 데이터보다 사용될 확률이 높다
* 순차적 지역성 : 여러 작업이 순서대로 진행되는 경향이 있다는 것
	
### (3) 페이지 교체 알고리즘
1. 무작위 페이지 교체 알고리즘 : 스왑 영역으로 쫓아낼 대상 페이지를 특별한 로직 없이 무작위로 선정
2. FIFO 페이지 교체 알고리즘 : 시간상으로 메모리에 가장 먼저 들어온 페이지를 대상 페이지로 선정
3. 최적 페이지 교체 알고리즘 : 앞으로 사용할 페이지를 미리 살펴보고 페이지 교체 선정 시점부터 사용 시점까지 가장 멀리 있는 페이지를 대상 페이지로 선정
4. LRU 페이지 교체 알고리즘 : 메모리에 올라온 후 가장 오랫동안 사용되지 않은 페이지를 대상 페이지로 선정
	4-1. 페이지 접근 시간에 기반한 구현 : 접근한지 가장 오래된 페이지
	4-2. 카운터에 기반한 구현 : 접근 시간을 카운터 숫자로 구현
	4-3. 참조 비트 시프트 방식 구현 : 접근하면 참조비트가 1로 바뀌며, 주기적으로 오른쪽으로 한 칸씩 이동하여 가장 작은 값이 대상 페이지
5. LFU 페이지 교체 알고리즘 : 프레임에 있는 페이지마다 그동안 사용된 횟수를 세어 가장 적은 페이지를 대상 페이지로 선정
6. NUR 페이지 교체 알고리즘 : 추가 비트를 통해 대상 페이지 선정, 같은 비트의 페이지가 여러 개면 무작위로 선정, 모두 (1,1)이면 리셋
	* 참조비트 : 페이지에 접근하면 1이 된다.
	* 변경비트 : 페이지가 변경되면 1이 된다.
7. FIFO 변형 알고리즘
	7-1. 2차 기회 페이지 교체 알고리즘 : 특정 페이지에 접근하여 페이지 부재 없이 성공할 경우, 해당 페이지를 큐의 맨 뒤로 이동
	7-2. 시계 알고리즘
		* 원형 큐를 사용하며, 가리키는 페이지가 스왑 영역으로 쫓겨나면 대상 포인터를 다음으로 이동한다.
		* 참조를 성공한 경우, 참조비트를 1로 변경하여 스왑 대상에서 제외하지만 제외할 때 참조비트를 0으로 리셋한다.
			
### (4) 스레싱
* 잦은 페이지 부재로 작업이 멈춘 것 같은 상태
* 스레싱 발생 지점 : 새로운 페이지를 메모리에 가져오는 작업이 빈번해져서 CPU가 작업할 수 없는 상태의 시점
	
### (5) 프레임 할당
* 프레임을 실행 중인 프로세스에 적절히 나누어주는 정책
* 정적 할당 : 프로세스 실행 초기에 프레임을 나눠준 후 그 크기를 고정
	* 균등 할당 : 프로세스의 크기와 상관없이 사용 가능한 프레임을 모든 프로세스에 동일하게 할당
	* 비례 할당 : 프로세스의 크기에 비례하여 프레임을 할당
* 동적할당
	1. 작업집합 모델 : 최근 일정 시간 동안 참조된 페이지들을 집합으로 만들고, 이 집합에 있는 페이지들을 물리 메모리에 유지
		* 작업집합 크기 : 작업집합 모델에서 물리 메모리에 유지할 페이지의 크기
		* 작업집합 윈도우 : 작업집합에 포함되는 페이지의 범위
	2. 페이지 부재 빈도 : 페이지 부재 횟수를 기록하여, 페이지 부재 비율을 계산하는 방식. 부재 비율에 따라 할당, 회수
	
### (6) 페이지 전역교체, 지역교체
* 전역교체 : 전체 프레임을 대상으로 교체 알고리즘을 적용
* 지역교체
	* 페이지를 요청한 프로세스와 관련된 프레임을 대상으로 교체 알고리즘 적용
	* 장점 : 자신에게 할당된 프레임의 전체 개수에 변화가 없기 때문에 페이지 교체가 다른 프로세스에 영향이 없음.
	* 단점 : 자주 사용하는 페이지가 스왑 영역으로 옮겨져 시스템의 효율이 떨어질 수 있음.

### (7) 페이지 테이블 크기
* 페이지 테이블의 크기를 줄이기 위해 한 페이지의 크기를 크게하는 것이 좋을 수 있으나, 페이지의 크기가 커지면 내부 단편화 발생
	
### (8) 쓰기 시점 복사
* 프로세스들이 메모리를 공유하고 있는 상태에서, 각 프로세스가 사용하는 변수는 공유할 수 없기 때문에 별도의 메모리 공간이 필요하다.
* 이 때, 처음부터 미리 확보해두지 않고 데이터의 변화가 있을 때까지 새로운 프레임 할당을 미루는 것
	
### 연습문제
1. 메모리 가져오기 정책 중, 사용자가 요구할 때 해당 페이지를 메모리로 가져오는 방식은 무엇인가?
	* 요구페이징
2. 요구 페이징과 반대로 앞으로 필요할 것이라고 예상되는 페이지를 미리 가져오는 방식은 무엇인가?
	* 미리 가져오기
3. 페이지 테이블 엔트리의 구조 중, 페이지가 실제 메모리에 있는지 나타내는 비트는 무엇인가?
	* 유효 비트
4. 페이지 테이블 엔트리의 구조 중, 페이지가 메모리에 올라온 후 사용한 적이 있는지 알려주는 비트는 무엇인가?
	* 접근 비트
5. 페이지 테이블 엔트리의 구조 중, 페이지가 메모리에 올라온 후 데이터의 변경이 있었는지 알려주는 비트는 무엇인가?
	* 변경 비트
6. 프로세스가 페이지를 요청했을 때 해당 페이지가 메모리에 없는 상황을 무엇이라 하는가?
	* 페이지 부재
7. 기억장치에 접근하는 패턴이 메모리 전체에 고루 분포되는 것이 아니라 특정 영역에 집중되어 있는 성질을 무엇이라 하는가?
	* 지역성
8. 처음으로 메모리에 올라온 페이지를 스왑 영역으로 보내는 페이지 교체 알고리즘은 무엇인가?
	* FIFO 페이지 교체 알고리즘
9. 미래의 접근 패턴을 기준으로 대상 페이지를 선정하여 스왑 영역으로 보내는 방식으로, 실제로 구현이 불가능한 페이지 교체 알고리즘은 무엇인가?
	* 최적 페이지 교체 알고리즘
10. 시간적으로 멀리 떨어진 페이지를 스왑 영역으로 보내는 페이지 교체 알고리즘은 무엇인가?
	* LRU 페이지 교체 알고리즘
11. 사용 빈도가 적은 페이지를 스왑 영역으로 보내는 페이지 교체 알고리즘은 무엇인가?
	* LFU 페이지 교체 알고리즘
12. 최근에 사용한 적이 없는 페이지를 스왑 영역으로 보내는 페이지 교체 알고리즘은 무엇인가?
	* NUR 페이지 교체 알고리즘
13. FIFO 변형 페이지 교체 알고리즘 중, 성공한 페이지를 큐의 맨 뒤로 옮김으로써 기회를 한 번 더 주는 페이지 교체 알고리즘은 무엇인가?
	* 2차 기회 페이지 교체 알고리즘
14. FIFO 변형 페이지 교체 알고리즘 중, 대상 페이지를 가리키는 포인터를 사용하여 포인터가 큐의 맨 바닥으로 내려가면 다음에 다시 큐의 처음으로 가리키게 하는 페이지 교체 알고리즘은 무엇인가?
	* 시계 알고리즘
15. 하드디스크의 입출력이 많아져서 잦은 페이지 부재로 작업이 거의 멈춰버린 상태를 무엇이라 하는가?
	* 스레싱
16. 동적 프레임 할당 방식 중, 최근 일정 시간 동안 참조된 페이지를 집합으로 유지하고 이 집합에 있는 페이지들을 물리 메모리에 유지하는 것은 무엇인가?
	* 작업집합 모델
17.  동적 프레임 할당 방식 중, 페이지 부재 비율의 상한선과 하한선을 설정하고 페이지 부재 비율이 상한선을 초과하면 할당 프레임을 늘려주는 것은 무엇인가?
	* 페이지 부재 빈도
		
### 심화문제
1. 요구 페이징의 의미와 효과를 설명하시오.
	* 사용자가 요구할 때 해당 페이지를 메모리로 가져오는 것
	* 메모리를 효율적으로 관리, 응답속도 향상
2. 세그멘테이션 오류와 페이지 부재의 차이를 설명하시오.
	* 페이지 부재 : 페이지를 요청했을 때, 그 페이지가 메모리에 없는 상황, 스왑영역에서 해당 페이지를 물리 메모리로 옮긴 후 작업 진행
	* 세그멘테이션 오류 : 사용자의 프로세스가 주어진 메모리 공간을 벗어나거나 접근 권한 없는 곳에 접근하는 것으로, 해당 프로세스를 강제 종료하여 해결
3. 지역성의 의미를 설명하시오.
	* 기억장치에 접근하는 패턴이 메모리 전체에 고루 분포되는 것이 아니라 특정 영역에 집중되는 성질
	* 공간의 지역성 : 현재 위치에서 가까운 데이터에 접근할 확률이 먼 거리에 있는 데이터에 접근할 확률보다 높다는 것
	* 시간의 지역성 : 현재를 기준으로 가장 가까운 시간에 접근한 데이터가 더 먼 시간에 접근한 데이터보다 사용될 확률이 높다
	* 순차적 지역성 : 여러 작업이 순서대로 진행되는 경향이 있다는 것
4. LRU 페이지 교체 알고리즘의 동작을 설명하시오.
	* 메모리에 올라온 후 가장 오랫동안 사용되지 않은 페이지를 대상 페이지로 선정
	* 페이지 접근 시간에 기반한 구현 : 접근한지 가장 오래된 페이지
	* 카운터에 기반한 구현 : 접근 시간을 카운터 숫자로 구현
	* 참조 비트 시프트 방식 구현 : 접근하면 참조비트가 1로 바뀌며, 주기적으로 오른쪽으로 한 칸씩 이동하여 가장 작은 값이 대상 페이지
5. NUR 페이지 교체 알고리즘의 동작을 설명하시오.
	* 추가 비트를 통해 대상 페이지 선정, 같은 비트의 페이지가 여러 개면 무작위로 선정, 모두 (1,1)이면 리셋
	* 참조비트 : 페이지에 접근하면 1이 된다.
	* 변경비트 : 페이지가 변경되면 1이 된다.
6. 프레임 할당 방식 중 정적 할당에 대해 설명하시오.
	* 정적 할당 : 프로세스 실행 초기에 프레임을 나눠준 후 그 크기를 고정
		* 균등 할당 : 프로세스의 크기와 상관없이 사용 가능한 프레임을 모든 프로세스에 동일하게 할당
		* 비례 할당 : 프로세스의 크기에 비례하여 프레임을 할당
7. 프레임 할당 방식 중 동적 할당에 대해 설명하시오.
	* 동적할당
	1. 작업집합 모델 : 최근 일정 시간 동안 참조된 페이지들을 집합으로 만들고, 이 집합에 있는 페이지들을 물리 메모리에 유지
		* 작업집합 크기 : 작업집합 모델에서 물리 메모리에 유지할 페이지의 크기
		* 작업집합 윈도우 : 작업집합에 포함되는 페이지의 범위
	2. 페이지 부재 빈도 : 페이지 부재 횟수를 기록하여, 페이지 부재 비율을 계산하는 방식. 부재 비율에 따라 할당, 회수
		

---
## 9. 입출력 시스템과 저장장치

### (1) 주변장치
- 저속 주변장치 : 메모리와 주변장치 사이에 오고 가는 데이터의 양이 적어 데이터 전송률이 낮은 장치
- 고속 주변장치 : 메모리와 주변장치 사이에 대용량의 데이터가 오고 가므로 데이터 전송률이 높은 장치
	
### (2) 입출력 버스의 구조
- 폴링 방식 : 모든 장치가 하나의 버스로 연결되고, CPU가 작업을 진행하다가 입출력 명령을 만나면 직접 입출력장치에서 데이터를 가져오는 방식
- 입출력 제어기 : 주변 장치 관리를 대신 하는 것
- 채널 선택기 : 입출력 버스를 고속 입출력 버스, 저속 입출력 버스로 분리하여 두 버스 사이의 데이터 전송을 관리하는 것
- DMA 제어기 : 주변 장치와 메모리 사이의 데이터 접근 관리
	
### (3) 인터럽트
- 주변장치의 입출력 요구나 하드웨어의 이상 현상을 CPU에 알리는 역할
- 외부 인터럽트 : 입출력장치로부터 오는 인터럽트뿐 아니라 전원 이상이나 기 계적인 오류 때문에 발생하는 인터럽트
- 내부 인터럽트 : 프로세스 오류와 관련된 인터럽트
- 시그널 : 사용자의 의지로 발생시키는 자발적 인터럽트
- 인터럽트 벡터 : 여러 인터럽트 중 어떤 인터럽트가 발생했는지 파악하기 위해 사용하는 자료 구조
- 인터럽트 핸들러 : 인터럽트의 처리 방법을 함수 형태로 만들어 놓은 것, 인터럽트 벡터에 해당 인터럽트 핸들러의 메모리 주소가 포인터 형태로 등록됨

### (4) 버퍼
- 속도가 다른 두 장치의 속도 차이를 완화하는 역할
- 버퍼가 꽉 찼을 때 입출력장치로 데이터를 전송하도록 설계되어있으므로, 버퍼가 다 차지 않았을 때 장치가 제거될 경우, 데이터가 저장되지 않는 문제는 Flush를 사용해 강제로 저장

### (5) 하드디스크
- 플래터 : 데이터가 저장되는 곳
- 섹터 : 하드디스크의 가장 작은 단위
- 블록 : 하드디스크와 컴퓨터 사이에 데이터를 전송하는 논리적인 저장 단위 중 가장 작은 단위, 윈도우에서는 클러스터로 표현
- 트랙 : 플래터에서 회전축을 중심으로 데이터가 기록되는 동심원, 섹터의 집합
- 실린더 : 트랙의 집합
- 헤드 : 데이터를 읽고, 쓰기 위한 물리적인 장치
- 디스크 전송 시간
	- 탐색시간 : 섹터가 있는 트랙까지 헤드가 이동
	- 회전 지연 시간 : 플래터가 회전하여 원하는 섹터를 만날 때까지 기다리는 시간
	- 전송시간 : 섹터에 있는 데이터를 읽어서 전송하는 시간
- 파티션 : 디스크를 논리적으로 분할하는 작업
- 마운트 : 여러 개의 파티션을 하나로 통합하는 기능
- 포매팅 : 디스크를 초기화하는 작업
	- 느린 포매팅 : 모든 섹터를 0으로 만드는 것
	- 빠른 포매팅 : 데이터는 그대로 둔 채 파일 테이블을 초기화하는 방식
- 조각모음 : 데이터를 저장하고 지우는 과정에서 생긴 빈공간 조각 또는 단편들을 모으는 것

### (6) 네트워크 저장장치
- DAS : 서버와 같은 컴퓨터에 직접 연결된 저장장치, HAS
- NAS : 기존의 저장장치를 LAN이나 WAN에 붙여서 사용하는 방식, 저장장치를 네트워크상에 두고 여러 클라이언트가 네트워크를 통해 접근
- SAN : 데이터 서버, 백업 서버, RAID 등의 장치를 네트워크로 묶고 데이터 접근을 위한 서버를 두는 형태

### (7) 디스크 스케줄링
- FCFS : 요청이 들어온 트랙 순서대로 접근하는 것
- SSTF : 현재 헤드가 있는 위치에서 가장 가까운  트랙부터 접근하는 것
- 블록 SSTF : 큐에 있는 트랙 요청을 일정한 블록 형태로 묶고, 현재 틀랙에서 가장 먼 트랙을 블록의 끝으로 이동하여 접근하는 것
- SCAN : 헤드가 한 방향으로만 움직이면서 서비스를 하는 것
- C-SCAN : 헤드가 한쪽 방향으로 움직일 때는 요청받은 트랙에 접근하고, 반대 방향으로 돌아올 때에는 접근하지 않고 이동만 하는 것
- LOOK : 헤드가 한 방향으로 움직이나, 더 이상 접근할 트랙이 없으면 중간에서 방향을 바꾸는 것
- C-LOOK : 헤드가 한 방향으로 움직이나, 더 이상 접근할 트랙이 없으면 중간에서 방향을 바꾸는데 반대 방향으로 돌아올 때에는 접근하지 않고 이동만 하는 것
- SLTF : 드럼을 사용하는 일부 하드디스크에서 사용, 요청이 들어온 섹터의 순서를 디스크가 회전하는 방향에 맞춰서 정렬

### (8) RAID
- 자동으로 백업을 하고 장애가 발생하면 이를 복구하는 시스템
- RAID 0 : 여러 개의 디스크에 데이터를 동시에 입출력할 수 있도록 구성
- RAID 1 : 미러링, 22개의 디스크에 나누어 저장하여 장애 시 백업 디스크로 활용
- RAID 2 : 오류 검출 코드(패리티 비트), 오류 교정 코드(허밍코드)를 활용, 비트 단위로 저장, 각 비트의 오류 교정 코드를 구성하여 나중에 비트 단위로 복구
- RAID 3 : 패리티 비트를 사용해서 데이터 복구, 패리티 비트를 여러 섹터끼리 묶어서 구성하여 오류 섹터의 데이터를 복원 (N-Way 패리티 비트)
- RAID 4 : 데이터가 블록 단위로 구성, 모든 디스크가 동작해야하는 RAID 3과 달리 패리티 비트가 저장되는 디스크만 동작
- RAID 5 : 패리티 비트를 여러 디스크에 분산하여 구성함으로써 RAID 4의 병목 현상을 완화
- RIAD 6 : 패리티 비트가 한 개인 경우, 디스크 2개 동시에 장애가 발생했을 경우 복구가 불가능하기 때문에 패리티 비트를 2개로 구성하여 분산
- RAID 10 : RAID 0, RAID 1을 결합한 것
- RAID 50 : RAID 0, RAID 5를 결합한 것
- RAID 60 : RAID 0, RAID 6을 결합한 것, 두 번재 패리티 비트를 빼면 RAID 50

### (9) 연습문제
1. 전원 이상이나 기계적인 오류 때문에 발생하는 인터럽트는 무엇인가?
- 외부 인터럽트
2. 숫자를 0으로 나누거나 자신의 주소 공간을 벗어나서 작업을 하는 것과 같이 프로세스의 오류와 관련된 인터럽트는 무엇인가?
- 내부 인터럽트
3. 자발적 인터럽트로서 사용자의 의지로 발생시키는 인터럽트는 무엇인가?
- 시그널
4. 인터럽트의 처리 방법을 함수로 만들어놓은 것을 무엇이라 하는가?
- 인터럽트 핸들러
5. 하드디스크에서 사용하는 방식으로, 디스크가 일정 속도로 회전하며 모든 트랙의 섹터 개수가 같고 섹터의 크기가 각각 다른 방식은 무엇인가?
- 각속도 일정 방식
6. CD에서 사용하는 방식으로, 어느 트랙이나 시간당 디스크 이동 거리가 같고 섹터의 크기가 일정한 방식은 무엇인가?
- 선속도 일정 방식
7. 하드디스크 장치의 데이터 전송 시간 중, 현재 위치에서 원하는 트랙까지 이동하는데 걸리는 시간을 무엇이라 하는가?
- 탐색 시간
8. 하드디스크 장치의 데이터 전송 시간 중, 디스크가 회전하여 원하는 섹터를 만날 때까지 걸리는 시간을 무엇이라 하는가?
- 회전 지연 시 간
9. 네트워크 저장장치 중 저장장치를 네트워크 상에 두고 여러 클라이언트가 네트워크를 통해 접근함으로써 공유 데이터의 관리 및 데이터의 중복 회피가 가능한 기법은 무엇인가?
- NAS
10. 현재 헤드가 있는 위치에서 가장 가까이 있는 트랙부터 서비스하는 디스크 스케줄링 기법은 무엇인가?
- SSTF
11. 서비스를 요청한 트랙을 일정 단위로 묶어 SSTF방식으로 서비스하는 디스크 스케줄링 기법은 무엇인가?
- 블럭 SSTF
12. 헤드가 움직이기 시작하면 맨 마지막 트랙에 도착할 때까지 뒤돌아가지 않고 계속 앞으로 전진하는 디스크 스케줄링 기법은 무엇인가?
- SCAN
13. 헤드가 한쪽으로만 움직이지만 더 이상 서비스할 트랙이 없으면 끝까지 가지 않고 중간에서 방향을 바꾸는 디스크 스케줄링 기법은 무엇인가?
- LOOK
14. 장애 발생 시 복구하는 기능은 없으나 입출력 속도를 높이기 위해 사용하는 RAID 방식의 번호를 무엇인가?
- RAID 0
15. RAID 1(미러링)에서 추가로 필요한 디스크이 개수는 원본 디스크의 몇 배인가?
- 1배
16. 미러링과 스트라이핑을 결합한 RAID 방식의 번호는 무엇인가?
- RAID 10

### (10) 심화문제
1. 입출력 버스의 구조를 그림으로 그리고 설명하시오.
- ![image](https://user-images.githubusercontent.com/95995592/151692299-1bfbeb36-9d85-4466-967c-77fc9d13b313.png)
- 입출력 제어기 : 주변 장치 관리를 대신 하는 것
- 채널 선택기 : 입출력 버스를 고속 입출력 버스, 저속 입출력 버스로 분리하여 두 버스 사이의 데이터 전송을 관리하는 것
- 그래픽 카드는 대용량 데이터를 다루므로 메인버스에 바로 연결한다.

2. 인터럽의 종류를 나열하고 설명하시오.
- 외부 인터럽트 : 입출력장치로부터 오는 인터럽트뿐 아니라 전원 이상이나 기 계적인 오류 때문에 발생하는 인터럽트
- 내부 인터럽트 : 프로세스 오류와 관련된 인터럽트
- 시그널 : 사용자의 의지로 발생시키는 자발적 인터럽트
3. 각속도 일정 방식과 선속도 일정 방식에 대해 설명하시오.
- 각속도 일정 방식 : 디스크가 작동하는 동안 플래터가 일정한 속도로 회전
- 선속도 일정 방식 : 헤드 위치에 따라 디스크의 회전 속도가 변하는 방식
4. SSTF 디스크 스케줄링의 장단점을 설명하시오.
- 장점 : 스케줄링 효율성이 좋다.
- 단점 : 아사현상이 발생할 수 있다.
5. LOOK 디스크 스케줄링이 만들어진 이유를 설명하시오.
- SCAN 디스크 스케줄링의 불필요한 부분을 제거하여 효율을 높이기 위해서
6. C-SCAN 디스크 스케줄링에 대해 설명하시오.
- 헤드가 한 방향으로 움직이나, 더 이상 접근할 트랙이 없으면 중간에서 방향을 바꾸는데 반대 방향으로 돌아올 때에는 접근하지 않고 이동만 하는 것
7. RAID 10번과 RAID 0+1을 비교하여 설명하시오.
- RAID 10 : 장애가 발생했을 때, 일부 디스크만 중단
- RAID 0+1 : 장애가 발생했을 때, 복구하기 위해 모든 디스크를 중단


---
## 10. 파일 시스템

### (1) 파일시스템
- 사용자 대신 파일을 보관하고 관리하는 파일관리자를 두어 저장장치의 전체 관리를 맡기는 것
- 기능
	1) 파일 구성
	2) 파일 관리
	3) 접근 권한 관리
	4) 접근 방법 제공
	5) 무결성 보장
	6) 백업과 복구
	7) 암호화
- 블록 : 저장장치에서 사용하는 가장 작은 단위, 한 블록에 주소 하나가 할당, 여러 섹터를 묶어 하나의 블록을 만들고 블록 하나에 주소 하나를 배정
- 블록 크기를 작게 설정하면 내부 단편화 현상이 줄어들지만, 파일이 여러 블로긍로 나뉘어 파일 입출력 속도가 느려진다. 큰 파일을 많이 사용할 때는 블록 크기를 크게 잡는 것이 좋다

### (2) 파일 구조
1) 순차 파일 구조
	* 파일 내용이 하나의 긴 줄로 늘어선 형태
	* 모든 데이터가 순서대로 기록되기 때문에 저장 공간에 낭비되는 부분이 없다.
	* 구조가 단순하여 테이프는 물론 플로피디스크나 메모리를 이요한 저장장치에도 적용할 수 있다.
	* 순서대로 데이터를 읽거나 저장할 때 매우 빠르게 처리된다.
	* 새로운 데이터를 삽입하거나 삭제할 때 시간이 많이 걸린다.
	* 특정 데이터로 이동할 때 직접 접근이 어렵다
2) 인덱스 파일 구조
	* 순차 파일 구조에 인덱스 테이블을 추가하여 순차 접근과 직접 접근이 가능
	* 인덱스 테이블을 여러 개 만들면 다양한 접근이 가능
3) 직접 파일 구조
	* 저장하려는 데이터의 특정 값에 어떤 관계를 정의하여 물리적인 주소로 바로 변환하는 파일 구조
	* 특정 함수를 이용하여 직접 접근이 가능한 파일 구조, 해시 함수
	* 함수를 이용하여 접근이 매우 빠르다
	* 적절한 해시 함수의 선정이 어렵다

### (3) 디스크 파일 할당
* 연속 할당
	* 파일을 구성하는 데이터를 디스크상에 연속적으로 배열하는 간단한 방식
	* 파일의 시작 블록만 알면 전체 파일을 찾을 수 있다. 
	* 파일을 저장하거나 삭제하다보면 빈 공간이 생기는데, 디스크에 남는 공간 중 파일의 크기와 맞는 연속된 공간이 없을 때는 연속 할당이 불가능
* 불연속 할당 : 비어 있는 블록에 데이터를 분산하여 저장하고, 이에 관한 정보를 파일시스템이 관리하는 방식
	* 연결 할당
		* 파일에 속한 데이터를 연결 리스트로 관리하는 방식
		* 테이블 형태로 관리
		* 하나의  파티션이 사용할 수 있는 디스크 용량이 테이블의 주소 크기로 제한
	* 인덱스 할당
		* 데이터의 인덱스를 담고있는 인덱스 블록을 연결
		* 인덱스 블록은 실제 데이터의 위치에 관한 정보를 순서대로 보관
		* I-node 테이블
			* 파일 제어 블록 : 파일 소유자와 각종 속성을 나타낸다. 파일에 대한 모든 권한의 정보를 포함하고 있기 때문에 슈퍼블록이라고도 함.
			* 블록 포인터 : 데이터가 있는 블록의 위치를 직접 연결하는 포인터
			* 간접 포인터 : 파일크기가큰 경우, 블록 포인터가 다 차면 인덱스 블록을 생성한 후 간접 포인터를 생성하여 인덱스 블록을 연결
			* 이중/삼중 간접 포인터 : 인덱스 블록 하나는 256개의 블록을 지정할 수 있다. 파일이 큰 경우, 여러개의 간접 포인터를 이용해 연결

### (4) 디스크의 빈 공간 관리
* 빈 공간 리스트 : 빈 블록의 정보만 모아놓은 것
* 파일이 사용했던 공간을 일일이 지우지 않고, 파일 테이블의 헤더를 삭제하고 사용했던 블록을 빈 공간 리스트에 등록하는 것으로 파일이 삭제된 것으로 간주
* 해당 블록에 새로운 데이터를 덮어쓰지 않는 한 원래 데이터를 복구할 수 있는 여지를 남긴다.

### 연습문제
1. 파일을 사용할 때 운영체제로부터 부여받은 접근 권한을 무엇이라 하는가?
	- 파일 디스크립터
2. 파일 구조 중 처음부터 순서대로 접근하는 구조는 무엇입니까?
	- 순차 파일 구조
3. 파일 구조 중 순차 접근과 직접 접근이 모두 가능한 구조는 무엇인가?
	- 인덱스 파일 구조
4. 저장하려는 데이터의 특정 값에 어떤 관계를 정의하여 물리적인 주소로 바로 변환하는 파일 구조는 무엇인가?
	- 직접 파일 구조
5. 직접 파일 구조에서 데이터의 변환헤서 사용하는 함수는 무엇인가?
	- 해시 함수
6. 파일이 전체 디렉터리 가운데 어느 위치에 있는지 나타내는 정보는 무엇인가?
	- 경로
7. 루트 디렉터리를 기준으로 정하는 경로와 현재 디렉터리를 기준으로 정하는 경로를 각각 무엇이라 하는가?
	- 절대 경로, 상대 경로
8. 여러 개로 나뉜 파티션을 하 나로 묶는 명령어는 무엇인가?
	- 마운트
9. 디스크 할당 방식에서 파일에 속한 데이터를 연결 리스트로 관리하는 방식은 무엇인가?
	- 연결 할당 방식
10. 윈도우의 FAT는 어떤 파일 할당 방식을 사용하는가?
	- 연결 할당 방식
11. 디스크 할당 방식에서 데이터의 인덱스를 담고 있는 인덱스 블록끼리 연결하여 최대 할당 크기의 제약이 없는 방식은 무엇인가?
	- 인덱스 할당 방식
12. 유닉스의 I-node는 어떤 할당 방식을 사용하는가?
	- 인덱스 할당 방식
13. 디스크의 빈 공간을 관리하기 위해 사용하는 자료 구조는 무엇인가?
	- 빈 공간 리스트
14. 빈 공간 리스트에서 방금 지워진 파일은 리스트의 어느 쪽에 추가되는가?
	- tail

### 심화문제
1. 순차 파일 구조에 대해서 설명하시오.
* 파일 내용이 하나의 긴 줄로 늘어선 형태
* 모든 데이터가 순서대로 기록되기 때문에 저장 공간에 낭비되는 부분이 없다.
* 구조가 단순하여 테이프는 물론 플로피디스크나 메모리를 이요한 저장장치에도 적용할 수 있다.
* 순서대로 데이터를 읽거나 저장할 때 매우 빠르게 처리된다.
* 새로운 데이터를 삽입하거나 삭제할 때 시간이 많이 걸린다.
* 특정 데이터로 이동할 때 직접 접근이 어렵다
2. 인덱스 파일 구조에 대해서 설명하시오.
* 순차 파일 구조에 인덱스 테이블을 추가하여 순차 접근과 직접 접근이 가능
* 인덱스 테이블을 여러 개 만들면 다양한 접근이 가능
3. 직접 파일 구조에 대해서 설명하시오.
* 저장하려는 데이터의 특정 값에 어떤 관계를 정의하여 물리적인 주소로 바로 변환하는 파일 구조
* 특정 함수를 이용하여 직접 접근이 가능한 파일 구조, 해시 함수
* 함수를 이용하여 접근이 매우 빠르다
* 적절한 해시 함수의 선정이 어렵다
4. 경로의 의미와 종류를 설명하시오.
* 의미 : 파일이 전체 디렉터리 중 어디에 있는지를 나타내는 정보
* 종류
	* 절대 경로 : 루트 디렉터리를 기준으로 파일의 위치를 나타내는 방식
	* 상대 경로 : 자신이 위치한 디렉터리를 기준으로 파일의 위치를 
5. 디스크 할당 방식의 연속 할당과 불연속 할당에 대해 설명하시오.
* 연속 할당
	* 파일을 구성하는 데이터를 디스크상에 연속적으로 배열하는 간단한 방식
	* 파일의 시작 블록만 알면 전체 파일을 찾을 수 있다. 
	* 파일을 저장하거나 삭제하다보면 빈 공간이 생기는데, 디스크에 남는 공간 중 파일의 크기와 맞는 연속된 공간이 없을 때는 연속 할당이 불가능
* 불연속 할당 : 비어 있는 블록에 데이터를 분산하여 저장하고, 이에 관한 정보를 파일시스템이 관리하는 방식
	* 연결 할당
		* 파일에 속한 데이터를 연결 리스트로 관리하는 방식
		* 테이블 형태로 관리
		* 하나의  파티션이 사용할 수 있는 디스크 용량이 테이블의 주소 크기로 제한
	* 인덱스 할당
		* 데이터의 인덱스를 담고있는 인덱스 블록을 연결
		* 인덱스 블록은 실제 데이터의 위치에 관한 정보를 순서대로 보관
		* I-node 테이블
			* 파일 제어 블록 : 파일 소유자와 각종 속성을 나타낸다. 파일에 대한 모든 권한의 정보를 포함하고 있기 때문에 슈퍼블록이라고도 함.
			* 블록 포인터 : 데이터가 있는 블록의 위치를 직접 연결하는 포인터
			* 간접 포인터 : 파일크기가큰 경우, 블록 포인터가 다 차면 인덱스 블록을 생성한 후 간접 포인터를 생성하여 인덱스 블록을 연결
			* 이중/삼중 간접 포인터 : 인덱스 블록 하나는 256개의 블록을 지정할 수 있다. 파일이 큰 경우, 여러개의 간접 포인터를 이용해 연결
6. 디스크이 빈 공간 관리 방법을 설명하시오.
* 빈 공간 리스트 : 빈 블록의 정보만 모아놓은 것
* 파일이 사용했던 공간을 일일이 지우지 않고, 파일 테이블의 헤더를 삭제하고 사용했던 블록을 빈 공간 리스트에 등록하는 것으로 파일이 삭제된 것으로 간주
* 해당 블록에 새로운 데이터를 덮어쓰지 않는 한 원래 데이터를 복구할 수 있는 여지를 남긴다.
