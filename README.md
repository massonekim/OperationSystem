## 목차

1.[운영체제의 개요](#1.-운영체제의-개요)   
2.[프로세스와 스레드](#2.-프로세스와-스레드)   
3.[CPU 스케줄링](#3.-CPU-스케줄링)   
4.[프로세스 동기화](#4.-프로세스-동기화)   
5.[교착 상태](#5.-교착-상태)   
6.[물리 메모리 관리](#6.-물리-메모리-관리)   
7.[가상 메모리의 기초](#7.-가상-메모리의-기초)

---
## 1. 운영체제의 개요

### (1) 운영체제 정의

* 사용자에게 편리한 인터페이스 환경을 제공하고 컴퓨터 시스템의 자원을 효울적으로 관리하는 소프트웨어

### (2) 운영체제 역할

#### 자원관리 ( 목표 : 효율성 )
* 컴퓨터 자원 배분 및 회수
#### 자원보호 ( 목표 : 안정성 )
* 비정상적인 작업으로부터 자원 보호
#### 하드웨어 인터페이스 제공 ( 목표 : 확장성 )
* 다양한 하드웨어 장치를 사용할 수 있도록 인터페이스 제공
#### 사용자 인터페이스 제공 ( 목표 : 편리성 )
* 사용자가 운영체제를 편리하게 사용할 수 있도록 지원

### (3) 운영체제 구조

#### 커널
* 프로세스 관리, 메모리 관리, 저장장치 관리와 같은 핵심적인 기능을 모아놓은 것
* 프로세스 관리 : 프로세스에 CPU를 배분하고 작업에 필요한 제반 환경 제공
* 메모리 관리 : 프로세스에 작업 공간을 배치하고 실제 메모리보다 큰 가상공간 제공
* 파일 시스템 관리 : 데이터를 저장하고 접근할 수 있는 인터페이스 제공
* 입출력 관리 : 필요한 입력과 출력 서비스 제공
* 프로세스 간 통신 관리 : 공동 작업을 위한 각 프로세스 간 통신 환경 지원

#### 시스템 호출
* 사용자나 응용 프로그램으로부터 컴퓨터 자원을 보호하기 위해 자원에 직접 접근하는 것을 차단하고 보호하기 위해 만든 인터페이스

#### 드라이버
* 운영체제가 많은 하드웨어를 모두 사용할 수 있는 환경을 제공할 수는 없기에, 커널은 입출력의 기본적인 부분만 제공하고 하드웨어의 특성을 반영한 소프트웨어는 디바이스 드라이버의 형태로 커널이 실행될 때 함께 실행

#### 인터페이스
* 사용자와 응용 프로그램에 인접하여 커널에 명령을 전달하고 실행 결과를 사용자와 응옹 프로그램에 돌려주는 역할

---
## 2. 프로세스와 스레드

### (1) 프로세스 개념
* 실행 중인 프로그램

### (2) 프로세스 상태
* 생성 : 프로세스가 메모리에 올라와 실행 준비를 완료한 상태, 프로세스 제어 블록(PCB) 생성
* 준비 : 생성된 프로세스가 CPU에 올라갈 때까지 기다리는 상태
* 실행 : CPU에 올라가 실제 작업을 수행하는 상태
* 완료 : 프로세스가 종료된 상태. 프로세스 제어 블록(PCB) 삭제
* 대기 : 실행 상태에 있는 프로세스가 입출력을 요청하면 입출력이 완료될 때까지 기다리는 상태. 입출력이 완료되면 준비 상태로 간다.

### (3) 프로세스 제어 블록(PCB)
* 프로세스를 실행하는 데 필요한 중요한 정보를 보관하는 자료 구조
* 포인터 : 프로세스 제어 블록의 첫 번째 블록에 위치하여 프로세스 제어 블록을 연결하여 준비상태나 대기상태의 큐를 구현하기 위한 것
* 프로세스 상태 : 프로세스가 현재 어떤 상태에 있는지를 나타내는 것
* 프로세스 구분자 : 운영체제 내에 있는 여러 프로세스를 구별하기 위한 구분자
* 프로그램 카운터 : 다음에 실행될 명령어의 위치를 가리키는 것
* 프로세스 우선순위 : CPU스케줄러가 준비상태 또는 대기상태에 있는 프로세스 중 실행 상태로 옮겨야 할 프로세스를 선택할 때 기준
* 각종 레지스터 정보 : 누산기, 색인 레지스터, 스택 포인터와 같은 이전에 실행할 때 사용한 레지스터의 값을 보관
* 메모리 관리 정보 : 프로세스가 메모리상의 위치 정보, 경계 레지스터값, 한계 레지스터 값 등을 저장
* 할당된 자원 정보 : 프로세스를 실행하기 위해 사용하는 입출력 자원이나 오픈 파일 등에 대한 정보
* 계정 정보 : 계정정보, CPU할당시간, CPU 사용시간 등을 저장
* 부모 프로세스 구분자와 자식 프로세스 구분자 : 부모, 자식 프로세스의 구분자(PID) 저장

### (4) 프로세스 구조
* 코드 영역 : 프로그램의 본문이 기술된 영역, 읽기 전용
* 데이터 영역 : 코드가 실행되면서 사용하는 변수나 파일 등의 각종 데이터를 모아놓은 곳, 읽기/쓰기
* 스택 영역 : 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳

### (5) 스레드 개념
* 프로세스의 코드에 정의된 절차에 따라 CPU에 작업 요청을 하는 실행 단위

### (6) 멀티스레드 개념
* 프로세스 내 작업을 여러 개의 스레드로 분할함으로써 작업의 부담을 줄이는 프로세스 운영 기법

### (7) 멀티스레드 장단점
#### 장점
* 응답성 향상 : 한 스레드가 입출력으로 인해 작업이 진행되지 않더라도, 다른 스레드가 작업을 계속하여 사용자의 작업 요구에 빠르게 응답
* 자원 공유 : 한 프로세스 내에서 독립적인 스레드를 생성하면 프로세스가 가진 자원을 모든 스레드가 공유하게 되어 작업을 원할하게 진행
* 효율성 향상 : 불필요한 자원의 중복을 막음으로써 시스템의 효율 향상 
* 다중 CPU 지원 : 2개 이상의 CPU를 가진 컴퓨터에서 멀티스레드를 사용하면 다중 CPU가 멀티스레드를 동시에 처리하여 CPU 사용량이 증가하고 프로세스의 처리 시간 단축
#### 단점
* 모든 스레드가 자원을 공유하기 떄문에 한 스레드에 문제가 생기면 전체 프로세스에 영향을 미친다.

### 연습문제
1. 프로그램이 프로세스가 되려면 운영체제로부터 무엇을 받아야 하는가?
* 프로세스 제어 블록(PCB)
2. 프로세스의 상태중 CPU를 할당받기 위해 기다리는 상태는 무엇인가?
* 준비 상태
3. 프로세스의 상태 중 입출력 작업을 하기 위해 이동하는 상태는 무엇인가?
* 대기 상태
4. CPU스케줄러가 준비상태에 있는 프로세스 중 하나를 골라 CPU를 할당하는 작업을 무엇이라고 하는가?
* 디스패치
5. 유닉스에서 CTRL+Z 키를 눌러 프로세스가 중단되면 프로세스는 어떤 상태로 바뀌는가?
* 휴식 상태
6. 실행 상태에서 하나의 프로세스가 나가고 새로운 프로세스가 들어오는 상황을 무엇이라고 하는가?
* 문맥 교환
7. 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 시스템 호출은 무엇인가?
* fork()
8. 프로세스의 골격은 그대로 둔 채 코드 영역만 바꾸는 시스템 호출은 무엇인가?
* exec()
9. 부모 프로세스가 기다리지 않아 자원이 회수되지 못하고 계속 살아 있는 프로세스는 무엇인가?
* 고아 프로세스
10. 프로세스의 코드에 정의된 절차에 따라 CPU에 작업 요청을 하는 실행 단위로서 가벼운 프로세스라고 불리는 것은 무엇인가?
* 스레드
11. 고아 프로세스를 방지하기 위해 부모 프로세스는 어떤 시스템 호출을 사용하는가?
* wait()
12. 작업이 끝난 프로세스의 자원을 회수하는 행위를 무엇이라고 하는가?
* Garbage collection
13. 모든 프로세스를 부모-자식 관계로 만들어 자원 회수를 용이하게 하는 프로세스의 구조는 무엇인가?
* 계층 구조

### 심화문제
1. 다섯 가지 프로세스 상태도를 그리시오.
* ![다운로드](https://user-images.githubusercontent.com/95995592/146670169-fb7ae22d-d67b-4f49-88db-a4897533724f.jpg)
2. 프로세스의 상태 중 휴식사앹와 보류상태에 대해 설명하시오.
* 휴식 상태 : 프로세스가 작업을 일시적으로 쉬고 있는 상태
* 보류 상태 : 프로세스가 메모리에서 잠시 쫓겨난 상태
3. 프로세스 제어 블록의 구성에 대해 설명하시오.
* 프로세스를 실행하는 데 필요한 중요한 정보를 보관하는 자료 구조
* 포인터 : 프로세스 제어 블록의 첫 번째 블록에 위치하여 프로세스 제어 블록을 연결하여 준비상태나 대기상태의 큐를 구현하기 위한 것
* 프로세스 상태 : 프로세스가 현재 어떤 상태에 있는지를 나타내는 것
* 프로세스 구분자 : 운영체제 내에 있는 여러 프로세스를 구별하기 위한 구분자
* 프로그램 카운터 : 다음에 실행될 명령어의 위치를 가리키는 것
* 프로세스 우선순위 : CPU스케줄러가 준비상태 또는 대기상태에 있는 프로세스 중 실행 상태로 옮겨야 할 프로세스를 선택할 때 기준
* 각종 레지스터 정보 : 누산기, 색인 레지스터, 스택 포인터와 같은 이전에 실행할 때 사용한 레지스터의 값을 보관
* 메모리 관리 정보 : 프로세스가 메모리상의 위치 정보, 경계 레지스터값, 한계 레지스터 값 등을 저장
* 할당된 자원 정보 : 프로세스를 실행하기 위해 사용하는 입출력 자원이나 오픈 파일 등에 대한 정보
* 계정 정보 : 계정정보, CPU할당시간, CPU 사용시간 등을 저장
* 부모 프로세스 구분자와 자식 프로세스 구분자 : 부모, 자식 프로세스의 구분자(PID) 저장
4. 문맥교환에 대해 설명하시오.
* CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업으로, 프로세스 제어 블록의 내용이 변경됨.
5. 프로세스를 구성하는 코드 영역, 데이터 영역, 스택 영역에 대해 설명하시오.
* 코드 영역 : 프로그램의 본문이 기술된 영역, 읽기 전용
* 데이터 영역 : 코드가 실행되면서 사용하는 변수나 파일 등의 각종 데이터를 모아놓은 곳, 읽기/쓰기
* 스택 영역 : 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳
6. fork() 시스템 호출의 장점을 설명하시오
* 기존 메모리에서 복사하는 구조로 프로세스의 생성 속도가 빠르다.
* 추가 자원 작업 없이 자원을 상속할 수 있다.
* 부모, 자식 프로세스 구분자로 연결되어 있음으로 정리를 부모 프로세스에 맡김으로써 시스템 관리를 효율적으로 할 수 있다.
7. exec() 시스템 호출을 사용하는 이유를 설명하시오.
* 프로세스의 구조체를 재활용함으로써, PCB, 메모리 영역, 부모-자식 관계를 그대로 사용할 수 있음으로 운영체제의 작업이 수월하다.
8. 프로세스 계층 구조의 장점을 설명하시오
* 동시에 여러 작업을 처리하고, 종료된 프로세스의 자원을 회수하는데 유용하다.
9. 멀티스레드, 멀티태스킹, 멀티프로세싱, CPU멀티스레드를 비교하여 설명하시오.
* 멀티스레드 : 프로세스 내 작업을 여러 개의 스레드로 분할함으로써 작업의 부담을 줄이는 프로세스 운영 기법
* 멀티태스킹 : 운영체제가 CPU에 작업을 줄 때 시간을 잘게 나누어(타임퀀텀) 배분하여, 여러 프로세스가 동시에 작업하는 것 처럼 보이게 배분하는 기법
* 멀티프로세싱 : CPU를 여러 개 사용하여 여러 개의 스레드를 동시에 처리하는 작업 환경
* CPU 멀티스레드 : 한 번에 하나씩 처리해야 하는 스레드를 파이프라인 기법을 이용하여 동시에 여러 스레드를 처리하도록 만든 병렬 처리 기법

---

## 3. CPU 스케줄링

### (1) CPU 스케줄링
  * 메모리에 올라온 프로세스들중 어떤 프로세스를 먼저 처리할지 일들의 순서를 정하는 것

### (2) 스케줄링 단계
  * 고수준 스케줄링 : 시스템 내의 전체 작업 수를 조절
  * 저수준 스케줄링 : 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 등을 결정
  * 중간 수준 스케줄링 : 중지와 활성화로 전체 시스템의 활성화된 프로세스 수를 조절하여 과부하 방지

### (3) 스케줄링 목적
  * 공평성 : 모든 프로세스가 자원을 공평하게 배정받아야 하며, 자원 배정 과정에서 특정 프로세스가 배제되어서는 안 된다.
  * 효율성 : 시스템 자원이 유휴 시간 없이 사용되도록 스케줄링 하고, 유휴 자원을 사용하려는 프로세스에는 우선권을 주어야 한다.
  * 안정성 : 우선순위를 사용하여 중요 프로세스가 먼저 작동하도록 배정함으로써 시스템 자원을 점유하거나 파괴하려는 프로세스로부터 자원 보호
  * 확장성 : 프로세스가 증가해도 시스템이 안정적으로 작동하도록 조치
  * 반응 시간 보장 : 적절한 시간 안에 프로세스의 요구에 반응
  * 무한 연기 방지 : 특정 프로세스의 작업이 무한히 연기되는 것을 방지

### (4) 스케줄링 시 고려 사항
  1. 선점형 스케줄링과 비선점형 스케줄링
    * 선점형 : 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 방식
      * 장점 : 프로세스가 CPU를 독점할 수 없어 대화형이나 시분할 시스템에 적합
      * 단점 : 문맥 교환의 오버헤드가 많다
    * 비선점형 : 어떤 프로세스가 CPU를 점유하면 다른 프로세스가 이를 빼앗을 수 없는 스케줄링 방식
      * 장점 : CPU 스케줄러의 작업량이 적고 문맥 교환의 오버헤드가 적다
      * 단점 : 기다리는 프로세스가 많아 처리율이 떨어진다
  2. 프로세스 우선순위 
    * 커널 프로세스
    * 일반 프로세스 
  3. CPU 집중 프로세스와 입출력 집중 프로세스
    * CPU 집중 : 수학 연산과 같이 CPU를 많이 사용하는 프로세스
    * 입출력 집중 : 저장장치에서 데이터를 복사하는 일과 같이 입출력을 많이 사용하는 프로세스
    * 입출력 집중 프로세스가 실행 상태로 가면 입출력 요구에 의해 대기 상태로 옮겨지기 때문에 다른 프로세스가 CPU를 사용할 수 있으므로, 입출력 집중 프로세스를 먼저 실행 상태로 옮기는 것이 효율적이다.
  4. 전면 프로세스와 후면 프로세스
    * 전면 프로세스(상호작용 프로세스)
      * GUI를 사용하는 운영체제에서 화면의 맨 앞에 놓인 프로세스 현재 입력과 출력을 사용하는 프로세스
    * 후면 프로세스(일괄 작업 프로세스)
      * 사용자와 상호작용이 없는 프로세스

### (5) 다중 큐
  1. 준비 상태의 다중 큐
    * 준비 상태에 들어올 때마다 자신의 우선순위에 해당하는 큐의 마지막에 삽입
    * 고정 우선순위 방식 
      * 운영체제가 프로세스에 우선순위를 부여하면 프로세스가 끝날 때까지 바뀌지 않는 방식
      * 시스템의 상황이 시시각각 변하는데 우선순위를 고정하면 시스템의 변화에 대응하기 어려워 작업 효율이 떨어짐
    * 변동 수선순위 방식
      * 프로세스 생성 시 부여받은 우선순위가 프로세스 작업 중간에 변하는 방식
      * 구현하기 어렵지만, 시스템의 효율성을 높일 수 있음
  2. 대기 상태의 다중 큐
    * 같은 입출력을 요구한 프로세스끼리 모아놓은 다중 큐
    * 입출력이 동시에 끝날 경우 여러 개의 인터럽트가 한꺼번에 처리됨으로, 인터럽트 벡터라는 자료구조를 이용

### (6) 스케줄링 알고리즘
  1. 스케줄링 알고리즘의 선택 기준
    * CPU 사용률 : 전체 시스템의 동작 시간 중 CPU가 사용된 시간
    * 처리량 : 단위 시간당 작업을 마친 프로세스의 수
    * 대기 시간 : 작업을 요청한 프로세스가 작업을 시작하기 전까지 대기하는 시간
    * 응답 시간 : 프로세스 시작 후 첫 번째 출력 또는 반응이 나올 때까지 걸리는 시간
    * 반환 시간 : 프로세스가 생성된 후 종료되어 사용하던 자원을 모두 반환하는 데까지 걸리는 시간
  2. FCFS 스케줄링
    * 준비 큐에 도착한 순선대로 CPU를 할당하는 비선점형 방식
  3. SJF 스케줄링
    * 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 방식
  4. HRN 스케줄링
    * 최고 응답률 우선 스케줄링
    * 우선순위 : ( 대기시간 + CPU 사용시간 ) / CPU 사용 시간
  5. 라운드 로빈 스케줄링
    * 한 프로세스가 할당받은 시간동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식
    * 타임 슬라이스를 너무 작게 설정하면 문맥 교환이 너무 자주 일어나서 시스템의 전반적인 성능이 떨어진다.
  6. SRT 우선 스케줄링
    * 최소 잔류 시간 우선 스케줄링
    * 남은 시간을 주기적으로 계산하고, 남은 시간이 더 적은 프로세스와 문맥교환을 해야 하므로 추가 작업이 필요
  7. 우선순위 스케줄링
    * 우선순위를 반영한 스케줄링
  8. 다단계 큐 스케줄링
    * 우선순위에 따라 준비 큐를 여러개 사용하는 방식
    * 고정형 우선순위
  9. 다단계 피드백 큐 스케줄링
    * CPU를 사용하고 난 프로세스의 우선순위가 낮아지는 방식의 다단계 큐 스케줄링
    * 마지막 큐는 타임 슬라이스를 무한대로 해서 FCFS 스케줄링 방식

### (7) 인터럽트
  * 개념
    * 입출력 하드웨어 등의 장치에 예외상황이 발생하여 처리가 필요할 경우에 CPU에 알려 처리할 수 있도록 하는 것
  * 동기적 인터럽트 : 프로세스가 실행 중인 명령어로 인해 발생
    * 프로그램상의 문제 때문에 발생하는 인터럽트
    * 컴퓨터 작업자가 의도적으로 프로세스를 중단하기 위해 발생시킨 인터럽트
    * 입출력장치 같은 주변장치의 조작에 의한 인터럽트
    * 산술 연산 중 발생하는 인터럽트
  * 비동기적 인터럽트 : 하드디스크 읽기 오류, 메모리 불량과 같은 하드웨어적인 오류로 발생
  * 인터럽트 처리 과정
    1. 현재 실행 중인 프로세스는 일시 정지 상태
    2. 인터럽트 컨트롤러가 실행되어 인터럽트의 처리 순서를 결정
    3. 인터럽트 벡터에 등록된 인터럽트 핸들러 실행
    4. 인터럽트 처리를 마치면 일시 정지된 프로세스가 다시 실행되거나 종료


### 연습문제
 1. 시스템 내 전체 프로세스의 수를 조절하는 것으로, 장기 스케줄링 또는 작업 스케줄링이라 불리는 스케줄링 수준은 무엇인가?
  * 고수준 스케줄링
 2. 어떤 프로세스에 CPU를 할당하고 어떤 프로세스를 대기 상태로 보낼지 등을 결정하는 스케줄링 수준은 무엇인가?
  * 저수준 스케줄링
 3. 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 스케줄링은 무엇인가?
  * 선점형 스케줄링
 4. 현재 입출력을 진행하는 프로세스로, 사용자와 상호작용이 가능하여 상호작용 프로세스라고도 불리는 것은 무엇인가?
  * 전면 프로세스
 5. 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 스케줄링 알고리즘은 무엇인가?
  * FCFS 스케줄링
 6. 준비 큐에 있는 프로세스 중 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 스케줄링 알고리즘은 무엇인가?
  * SJF 스케줄링
 7. SJF 스케줄링 알고리즘의 단점으로 크기가 큰 작업이 계속 뒤로 밀리는 현상을 무엇이라 하는가?
  * 아사 현상
 8. 아사 현상을 해결하는 방법을 설명하시오.
  * 에이징 : 프로세스가 양보할 수 있는 상한선을 정하는 방식
 9. 서비스를 받기 위해 대기한 시간과 CPU 사용 시간을 고려하여 우선순위를 정하는 스케줄링 알고리즘은 무엇인가?
  * HRN 스케줄링
 10. 프로세스가 할당받은 시간(타임 슬라이스)동안 작업하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 다음 자기 차례가 올 때까지 기다리는 선점형 스케줄링 알고리즘 중 가장 단순한 것은 무엇인가?
  * 라운드 로빈 스케줄링
 11. 타임 슬라이스의 크기와 문맥 교환의 관계를 설명하시오.
  * 타임 슬라이스를 너무 작게 설정하면 문맥 교환이 너무 자주 일어나 문맥 교환에 걸리는 시간이 실제 작업 시간보다 상대적으로 커지며, 문맥 교환에 많은 시간을 낭비하여 실제 작업을 못하는 문제가 발생
 12. 기본적으로 라운드 로빈 방식을 사용하지만, CPU를 할당받을 프로세스를 선택할 때 남아있는 작업 시간이 가장 적은 것을 선택하는 스케줄링 알고리즘은 무엇인가?
  * SRT 우선 스케줄링
 13. 우선순위에 따라 준비 큐를 여러 개 사용하며 고정형 우선순위를 적용하는 스케줄링 알고리즘은 무엇인가?
  * 우선순위 스케줄링
 14. 우선순위에 따라 준비 큐를 여러 개 사용하며, 프로세스가 CPU를 사용한 후 우선순위가 낮아지는 특징을 가진 스케줄링 알고리즘은 무엇인가?
  * 다단계 피드백 큐 스케줄링
 15. 다단계 피드백 큐 스케줄링에서 마지막 큐에 있는 프로세스(우선순위가 가장 낮은 프로세스)의 타임 슬라이스 크기는 얼마인가?
  * 무한대
 16. 다단계 피드백 큐 스케줄링에서 우선순위가 낮아질수록 타임 슬라이스의 크기는 어떻게 변하는가?
  * 우선순위가 낮아질수록 해당 큐의 타임 슬라이스가 커진다.
 17. 다단계 피드백 큐 스케줄링에서 마지막 큐(우선순위가 가장 낮은 큐)는 어떤 스케줄링 알고리즘처럼 동작하는가?
  * FCFS 스케줄링

### 심화문제
 1. 스케줄링의 단계와 그 특징을 설명하시오.
  * 고수준 스케줄링 : 시스템 내의 전체 작업 수를 조절
  * 저수준 스케줄링 : 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 등을 결정
  * 중간 수준 스케줄링 : 중지와 활성화로 전체 시스템의 활성화된 프로세스 수를 조절하여 과부하 방지 
 2. 스케줄링의 목적을 설명하시오.
  * 공평성 : 모든 프로세스가 자원을 공평하게 배정받아야 하며, 자원 배정 과정에서 특정 프로세스가 배제되어서는 안 된다.
  * 효율성 : 시스템 자원이 유휴 시간 없이 사용되도록 스케줄링 하고, 유휴 자원을 사용하려는 프로세스에는 우선권을 주어야 한다.
  * 안정성 : 우선순위를 사용하여 중요 프로세스가 먼저 작동하도록 배정함으로써 시스템 자원을 점유하거나 파괴하려는 프로세스로부터 자원 보호
  * 확장성 : 프로세스가 증가해도 시스템이 안정적으로 작동하도록 조치
  * 반응 시간 보장 : 적절한 시간 안에 프로세스의 요구에 반응
  * 무한 연기 방지 : 특정 프로세스의 작업이 무한히 연기되는 것을 방지
 3. 선점형 스케줄링과 비선점형 스케줄링을 비교하여 설명하시오.
  * 선점형 : 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 방식
    * 장점 : 프로세스가 CPU를 독점할 수 없어 대화형이나 시분할 시스템에 적합
    * 단점 : 문맥 교환의 오버헤드가 많다
  * 비선점형 : 어떤 프로세스가 CPU를 점유하면 다른 프로세스가 이를 빼앗을 수 없는 스케줄링 방식
    * 장점 : CPU 스케줄러의 작업량이 적고 문맥 교환의 오버헤드가 적다
    * 단점 : 기다리는 프로세스가 많아 처리율이 떨어진다
 4. 스케줄링 알고리즘의 선택 기준에 대해 설명하시오.
  * CPU 사용률 : 전체 시스템의 동작 시간 중 CPU가 사용된 시간
  * 처리량 : 단위 시간당 작업을 마친 프로세스의 수
  * 대기 시간 : 작업을 요청한 프로세스가 작업을 시작하기 전까지 대기하는 시간
  * 응답 시간 : 프로세스 시작 후 첫 번째 출력 또는 반응이 나올 때까지 걸리는 시간
  * 반환 시간 : 프로세스가 생성된 후 종료되어 사용하던 자원을 모두 반환하는 데까지 걸리는 시간
 5. FCFS, SJF, HRN 스케줄링의 특징을 설명하시오
  * FCFS 스케줄링
    * 준비 큐에 도착한 순선대로 CPU를 할당하는 비선점형 방식
  * SJF 스케줄링
    * 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 방식
  * HRN 스케줄링
    * 최고 응답률 우선 스케줄링
    * 우선순위 : ( 대기시간 + CPU 사용시간 ) / CPU 사용 시간
 6. 라운드 로빈, SRT, 다단계 큐, 다단계 피드백 큐 스케줄링의 특징을 설명하시오.
  * 라운드 로빈 스케줄링
    * 한 프로세스가 할당받은 시간동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식
    * 타임 슬라이스를 너무 작게 설정하면 문맥 교환이 너무 자주 일어나서 시스템의 전반적인 성능이 떨어진다.
  * SRT 우선 스케줄링
    * 최소 잔류 시간 우선 스케줄링
    * 남은 시간을 주기적으로 계산하고, 남은 시간이 더 적은 프로세스와 문맥교환을 해야 하므로 추가 작업이 필요
  * 다단계 큐 스케줄링
    * 우선순위에 따라 준비 큐를 여러개 사용하는 방식
    * 고정형 우선순위
  * 다단계 피드백 큐 스케줄링
    * CPU를 사용하고 난 프로세스의 우선순위가 낮아지는 방식의 다단계 큐 스케줄링
    * 마지막 큐는 타임 슬라이스를 무한대로 해서 FCFS 스케줄링 방식 
 7. 아사 현상과 에이징에 대해 설명하시오.
  *  아사 현상 : 특정 프로세스가 다른 프로세스에 밀려 CPU를 사용하지 못하고 계속해서 뒤로 밀리는 현상
  *  에이징 : 프로세스가 양보할 수 있는 상한선을 정하는 방식 
 8. 타임 슬라이스의 크기를 정하는 것과 시스템 효율성에 대해 설명하시오
  * 타임 슬라이스가 큰 경우 : 하나의 작업이 끝난 뒤, 다음 작업이 사직되는 것처럼 보인다.
  * 타임 슬라이스가 작은 경우 : 타임 슬라이스를 너무 작게 설정하면 문맥 교환이 너무 자주 일어나 문맥 교환에 걸리는 시간이 실제 작업 시간보다 상대적으로 커지며, 문맥 교환에 많은 시간을 낭비하여 실제 작업을 못하는 문제가 발생
---

## 4. 프로세스 동기화

### (1) 프로세스 간 통신
 * 프로세스가 다른 프로세스와 데이터를 주고받는 프로세스 간 통신에는 네트워크로 연결된 다른 컴퓨터에 있는 프로세스와의 통신도 포함
 * 프로세스 간 통신의 종류
 	* 프로세스 내부 데이터 통신 : 하나의 프로세스 내에 2개 이상의 스레드가 종재하는 경우의 통신, 전역 변수나 파일을 이용
 	* 프로세스 간 데이터 통신 : 같은 컴퓨터에 있는 여러 프로세스끼리 통신, 공용 파일 또는 운영체제가 제공하는 파이프 사용
 	* 네트워크를 이용한 데이터 통신 :  여러 컴퓨터가 네트워크로 연결되어 있을 때도 가능한 통신, 소켓을 이용
 * 프로세스 간 통신의 분류
 	* 통신 방향에 따른 분류
 		* 방향 통신 : 데이터를 동시에 양쪽 방향으로 전송할 수 있는 구조, 소켓
 		* 반양방향 통신 : 데이터를 양쪽 방향으로 전송할 수 있지만 동시 전송은 불가능하고 특정 시점에 한쪽 방향으로만 전송, 무전기
 		* 단방향 통신 : 한쪽 방향으로만 데이터를 전송, 전역변수나 파이프
 	* 통신 구현 방식에 따른 분류
 		* 대기가 있는 통신 : 동기화를 지원하는 방식, 데이터를 받는 쪽은 데이터가 도착할 때까지 자동으로 대기 상태에 머문다.
 		* 대기가 없는 통신 : 동기화를 지원하지 않는 방식, 데이터를 받는 쪽은 바쁜 대기를 사용하여 데이터가 도착했는지 여부를 직접 확인

### (2) 공유 자원
  * 여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일 등

### (3) 임계구역
  * 개념 : 자원접근 순서에따라 실행 결과가 달라지는 프로그램의 영역
  * 해결 조건
    - 상호 배제 : 한 프로세스가 임계구역에 들어가면 다른 프로세스는 임계구역에 들어갈 수 없다.
    - 한정 대기 : 어떤 프로세스도 무한 대기하지 않아야 한다.
    - 진행의 융통성 : 한 프로세스가 다른 프로세스의 진행을 방해해서는 안 된다.
  * 세마포어 : 임계구역에 진입하기 전에 스위치를 사용 중으로 놓고 임계구역으로 들어가는 방법
  * 모니터 : 보호할 자원을 임계구역으로 숨기고 임계구역에서 작업할 수 있는 인터페이스만 제공하여 세마포어 알고리즘을 자동으로 처리하도록 설계함으로써 자원을 보호

### 연습문제
 1. 프로세스 간 통신에서 데이터를 양방향으로 전송 가능하지만 동시 전송은 불가능하고 특정 시점에 한쪽 방향으로만 전송할 수 있는 통신 방식은 무엇인가?
  - 반양방향 통신
 2. 상태 변화를 살펴보기 위해 반복문을 무한 실행하며 기다리는 것을 무엇이라 하는가?
  - 바쁜 대기
 3. 프로세스 간 통신에서 대기가 없는 통신과 대기가 있는 통신의 예를 각각 제시하시오.
  - 대기가 있는 통신 : 동기화를 지원하는 방식, 데이터를 받는 쪽은 데이터가 도착할 때까지 자동으로 대기 상태에 머문다. / 파이프, 소켓
  - 대기가 없는 통신 : 동기화를 지원하지 않는 방식, 데이터를 받는 쪽은 바쁜 대기를 사용하여 데이터가 도착했는지 여부를 직접 확인 / 전역 변수, 파일
 4. 파이프를 이용하여 통신할 때 파이프를 2개 사용하는 이유는 무엇인가?
  - 파이프를 이용한 통신은 단방향 통신이므로, 양방향 통신을 위해 2개 사용
 5. 공유 자원을 병행적으로 읽거나 쓰는 상황을 무엇이라 하는가?
  - 경쟁 조건
 6. 공유 자원의 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역은 무엇인가?
  - 임계구역
 7. 임계구역 해결 조건 중 한 프로세스가 임계구역에 들어갔을 때 다른 프로세스는 임계구역에 들어갈 수 없는 조건을 무엇이라 하는가?
  - 상호 배제
 8. 임계구역 해결 조건 중 한 프로세스가 다른 프로세스의 진행을 방해해서는 안 된다는 조건을 무엇이라 하는가?
  - 진행의 융통성
 9. 임계구역 문제를 하드웨어적으로 해결한 방식으로, 하드웨어의 지원을 받아 명령어를 실행하는 도중에 타임아웃이 걸리지 않도록 하는 방식을 무엇이라 하는가?
  - 검사와 지정 코드
 10. 세마포어의 Semaphore(n)에서 n은 무엇을 가르키는가?
  - 공유 가능한 자원의 수
 11. 세마포어에서 내부 변수를 RS라고 할 때 세아포어 P()의 내부 코드를 쓰시오
  - if RS>0 then RS = RS-1; else block();
 12. 세마포어에서 내부 변수를 RS라고 할 때 세아포어 V()의 내부 코드를 쓰시오
  - RS=RS+1; wake_up();
 13. 세마포어가 제대로 작동하지 않는 경우를 설명하시오
  - 프로세스가 세마포어를 사용하지 않고 바로 임계구역으로 들어간 경우
  - P()를 두 번 사용하여 wake_up 신호가 발생하지 않은 경우
  - P(), V()를 반대로 사용하여 상호 배제가 보장되지 않은 경우
 14. 세마포어의 내부 코드도 타임아웃이 걸리면 문제가 발생할 수도 있다. 그래서 내부 코드는 무엇으로 보호받는가?
  - 검사와 지정
 15. 공유 자원을 내부적으로 숨기고 공유 자원에 접근하기 위한 인터페이스만 제공함으로써 자원을 보호하고 프로세스 간에 동기화를 시키는 것으로, 세마포어의 단점을 해결하면서 임계구역 문제를 해결한 방식은 무엇인가?
  - 모니터  

### 심화문제
 1. 프로세스 간 통신을 통신 방향에 따라 분류하여 설명하시오
  - 양방향 통신 : 데이터를 동시에 양쪽 방향으로 전송할 수 있는 구조, 소켓
  - 반양방향 통신 : 데이터를 양쪽 방향으로 전송할 수 있지만 동시 전송은 불가능하고 특정 시점에 한쪽 방향으로만 전송, 무전기
  - 단방향 통신 : 한쪽 방향으로만 데이터를 전송, 전역변수나 파이프
 2. 대기가 있는 통신과 대기가 없는 통신의 의미를 설명하고 적절한 예를 제시하시오
  - 대기가 있는 통신 : 동기화를 지원하는 방식, 데이터를 받는 쪽은 데이터가 도착할 때까지 자동으로 대기 상태에 머문다. / 파이프, 소켓
  - 대기가 없는 통신 : 동기화를 지원하지 않는 방식, 데이터를 받는 쪽은 바쁜 대기를 사용하여 데이터가 도착했는지 여부를 직접 확인 / 전역 변수, 파일 
 3. 실생활의 예를 들어 임계구역 문제를 설명하시오
  - 생산자는 계속 물건을 생산해서 원형 버퍼에 넣고, 소비자는 계속 원형 버퍼에서 물건을 가져올 때, 생산자가 물건을 넣고 총량을 증가시키기 전에 소비자가 총량을 차감하여 오류가 발생
 4. 다음 코드의 문제점을 설명하시오
  - 전역 변수로 잠금을 구현한 코드로, 전역 변수의 상태를 변화하는 순간 타임 아웃이 발생하여 다른 프로세스가 수행된다면 동시에 임계구역에 진입하게 된다.
 5. 다음 코드의 문제점을 설명하시오
  - 전역 변수로 상호 배제와 한정 대기 조건을 충족하는 코드로, 서로 번갈아가면서 수행하기 때문에 진행의 융통성 조건을 보장하지 못한다.
 6. 파일을 이용하여 Test라는 문자를 주고받는 코드를 작성하시오
  - ```C
    #include <studio.h>
    #include <unistd.h>
    #include <fcntl.h>
    
    void main()
    {
      int pid, fd;
      char buf[5];
      
      fd = open("com.txt",0_RDWR);
      pid = fork();
      
      if(pid<0 || fd<0)
      {
       exit(-1);
      }
      else if(pid == 0)
      {
       write(fd,"Test",5);
       close(fd);
       exit(0);
      }
      else
      {
       wait(0);
       lseek(fd,0,SEEK_SET);
       read(fd,buf,5);
       printf("%s",buf);
       close(fd);
       exit(0);
      }
      
    }

    ```
---

## 5. 교착 상태

### (1) 교착 상태의 개요
 * 2개 이상의 프로세스가 다른 프로세스의 작업이 끝나기만 기다리며 작업을 더 이상 진행하지 못하는 상태

### (2) 자원 할당 그래프
 * 프로세스가 어떤 자원을 사용 중이고, 어떤 자원을 기다리고 있는지를 방향성이 있는 그래프로 표현한 것

### (3) 교착 상태 필요 조건
 * 상호 배제 : 한 프로세스가 사용하는 자원은 다른 프로세스와 공유할 수 없는 배타적인 자원이어야 한다.
 * 비선점 : 한 프로세스가 사용 중인 자원은 중간에 다른 프로세스가 빼앗을 수 없는 비선점 자원이어야 한다.
 * 점유와 대기 : 프로세스가 어떤 자원을 할당받은 상태에서 다른 자원을 기다리는 상태
 * 원형 대기 : 점유와 대기를 하는 프로세스 간의 관계가 원을 이뤄야 한다.

### (4) 교착 상태 해결 방법
 1. 예방 : 교착 상태를 유발하는 네 가지 조건이 발생하지 않도록 무력화하는 방식
  * 상호 배제 예방 : 독점적으로 사용할 수 있는 자원을 없애버리는 방법
  * 비선점 예방 : 모든 자원을 빼앗을 수 있도록 만드는 방법, 아사현상 유발
  * 점유와 대기 예방 : 자원을 점유한 상태에서 다른 자원을 기다리지 못하게 하는 방법
  	* 프로세스가 자신이 사용하는 모든 자원을 자세히 알기 어렵다
  	* 자원의 활용성이 떨어진다.
  	* 많은 자원을 사용하는 프로세스가 적은 자원을 사용하는 프로세스보다 불리하다
  	* 일괄 작업 방식으로 동작 
  * 원형 대기 예방 : 자원을 한 방향으로만 사용하도록 설정하는 방법
  	* 유연성이 떨어진다.
  	* 자원의 번호를 어떻게 붙이든 자원 사용에 제약이 따른다. 
 2. 회피 : 자원 할당량을 조절하여 교착 상태를 해결하는 방식
  * 자원의 총수와 현재 할당된 자원의 수를 기준으로 시스템을 안정 상태, 불안정 상태로 나누고 안정 상태를 유지하도록 자원을 할당
  * 은행원 알고리즘
  	* 각 프로세스의 기대 자원과 가용 자원을 비교하여 기대 자원이 가용 자원보다 작은 경우, 자원을 할당한다.
  	* 전체 자원 : 시스템 내 전체 자원의 수
  	* 가용 자원 : 시스템 내 현재 사용할 수 있는 자원의 수 ( 가용자원 = 전체 자원 - 모든 프로세스의 할당 자원 ) 
  	* 최대 자원 : 각 프로세스가 선언한 치대 자원의 수
  	* 할당 자원 : 각 프로세스에 현재 할당된 자원의 수
  	* 기대 자원 : 각 프로세스가 앞으로 사용할 자원의 수 ( 기대 자원 = 최대 자원 - 할당 자원 )
  	* 단점
  		* 프로세스가 자신이 사용할 모든 자원을 미리 선언해야 한다.
  		* 시스템의 전체 자원 수가 고정적이어야 한다.
  		* 모든 불안정 상태가 교착 상태가 되는 것은 아님에도 불구하고 자원을 할당하지 않는 것은 자원 낭비이다.
 3. 검출과 회복 : 자원 할당 그래프를 모니터링하면서 교착 상태를 검출하고 회복시키는 방법
  1) 검출
   * 타임아웃 : 일정 시간 동안 작업이 진행되지 않은 프로세스를 교착상태가 발생한 것으로 간주하여 처리
				* 데이터 일관성이 깨지는 문제를 해결하기 위해 체크포인트, 롤백을 사용
						* 체크포인트 : 작업을 하다가 문제가 발생하면 저장된 상태로 되돌아오기 위한 표식  
						* 스냅숏 : 체크포인트 설정 시 현재의 시스템 상태를 저장한 데이터
						* 롤백 : 과거의 체크포인트로 되돌아가는 것
   	* 단점
   		* 엉뚱한 프로세스가 강제 종료될 수 있다.
   		* 분산 시스템의 경우, 원격지에 있는 프로세스의 응답이 없는 것이 교착 상태 때문인지 네트워크 문제인지 정확히 알 수 없으므로 모든 시스템에 적용할 수 없다.  
   * 자원 할당 그래프 : 자원 할당 그래프를 사용해서 교착상태가 발생한 것을 검출하는 방법
  2) 회복
   * 교착 상태를 일으킨 모든 프로세스를 동시에 종료
   * 교착 상태를 일으킨 프로세스 중 하나를 골라 순서대로 종료
   	* 우선순위가 낮은 프로세스를 먼저 종료
   	* 우선순위가 같은 경우 작업 시간이 짧은 프로세스를 먼저 종료
   	* 위의 두 조건이 같은 경우 자원을 많이 사용하는 프로세스를 먼저 

### 연습문제
 1. 2개 이상의 프 로세스가 서로의 작업이 끝나기만 기다리며 작업을 더 이상 진행하지 못하는 상태를 무엇이라 하는가?
  - 교착 상태
 2. 프로세스가 어떤 자원을 사용 중이고 어떤 자원을 기다리고 있는지를 나타내는 방향성이 있는 그래프를 무엇이라 하는가?
  - 자원 할당 그래프
 3. 네 가지 교착 상태 필요조건에 대해 설명하시오.
  - 상호 배제 : 한 프로세스가 사용하는 자원은 다른 프로세스와 공유할 수 없는 배타적인 자원이어야 한다.
  - 비선점 : 한 프로세스가 사용 중인 자원은 중간에 다른 프로세스가 빼앗을 수 없는 비선점 자원이어야 한다.
  - 점유와 대기 : 프로세스가 어떤 자원을 할당받은 상태에서 다른 자원을 기다리는 상태
  - 원형 대기 : 점유와 대기를 하는 프로세스 간의 관계가 원을 이뤄야 한다.
 4. 교착 상태 해결 방법 중, 교착 상태를 유발하는 네 가지 조건을 무력화하는 방법은 무엇인가?
  - 교착 상태 예방
 5. 교착 상태 해결 방법 중, 교착 상태가 발생하지 않는 수준으로 자원을 할당하는 방법은 무엇인가?
  - 교착 상태 회피
 6. 교착 상태 해결 방법 중, 자원 할당 그래프를 사용하여 교착 상태를 발견하는 방법은 무엇인가?
  - 교착 상태 검출
 7. 교착 상태 해결 방법 중, 타임아웃을 이용하여 해결하는 방법은 무엇인가?
  - 교착 상태 검출
 8. 교착 상태 해결 방법 중, 은행원 알고리즘을 사용하여 해결하는 방법은 무엇인가?
  - 교착 상태 회피
 9. 교착 상태 해결 방법 중, 모든 자원에 번호를 부여하고 낮은 번호의 자원을 사용할 수 없도록 하는 방법은 무엇인가?
  - 교착 상태 예방 - 원형 대기 예방
 10. 교착 상태 해결 방법 중, 프로세스가 시작 초기에 자신이 사용하려는 모든 자원을 한꺼번에 점유하거나, 그렇지 못할 경우 자원을 모두 반납하는 방법은 무엇인가?
  - 교착 상태 예방 - 점유와 대기 예방
 11. 교착 상태 해결 방법 중, 교착 상태가 검출되면 교착 상태를 일으킨 모든 프로세스를 종료하는 방법은 무엇인가?
  - 교착 상태 회복
 12. 자원 할당 그래프에서 무엇이 발견되면 교착 상태라고 판단할 수 있는가?
  - 사이클

### 심화문제
 1. 교착 상태 해결 방법 중, 프로세스가 시작 초기에 자신이 사용하려는 모든 자원을 한꺼번에 점유하거나, 그렇지 못할 경우 자원을 모두 반납하는 방법이 있다. 이 방법의 단점을 설명하시오.
  - 프로세스가 자신이 사용하는 모든 자원을 자세히 알기 어렵다
  - 자원의 활용성이 떨어진다.
  - 많은 자원을 사용하는 프로세스가 적은 자원을 사용하는 프로세스보다 불리하다
  - 일괄 작업 방식으로 동작 
 2. 교착 상태 회피 방법인 은행원 알고리즘의 단점을 설명하시오.
  - 프로세스가 자신이 사용할 모든 자원을 미리 선언해야 한다.
  - 시스템의 전체 자원 수가 고정적이어야 한다.
  - 모든 불안정 상태가 교착 상태가 되는 것은 아님에도 불구하고 자원을 할당하지 않는 것은 자원 낭비이다.
 3. 교착 상태 검출 시 타임아웃을 이용하는 방법의 장단점을 설명하시오.
  - 단점
    + 엉뚱한 프로세스가 강제 종료될 수 있다.
    + 분산 시스템의 경우, 원격지에 있는 프로세스의 응답이 없는 것이 교착 상태 때문인지 네트워크 문제인지 정확히 알 수 없으므로 모든 시스템에 적용할 수 없다.  
  - 장점 : 특별한 알고리즘이 없어 쉽게 구현할 수 있다. 

---
## 6. 물리 메모리 관리

### (1) 컴파일러
* 정의
	- 소스코드를 컴퓨터가 실행할 수 있는 기계어로 번역한 후, 한꺼번에 실행한다. ( C, JAVA 등 )

* 목적
	- 오류 발견 : 심벌테이블을 사용하여 소스코드에서 오류를 발견하여 실행 시 문제가 없도록 하는 것
	- 코드 최적화 : 실행하기 전에 코드를 점검하여 오류를 수정하고 최적화함으로써 작고 빠른 실행 파일 생성 

* 과정
	- 1) 소스코드 작성 및 컴파일 : 소스코드를 작성후 일차로 번역하여 목적코드 생성
	- 2) 목적코드와 라이브러리 연결
	- 3) 동적 라이브러리를 포함하여 최송 실행 

### (2) 인터프리터
* 소스코드를 한 행씩 번역하여 실행한다. ( 자바스크립트, 베이직 등 )

### (3) 메모리 관리자
* 역할
	- 가져오기 : 프로세스와 데이터를 메모리로 가져오는 것, 메모리가 충분하지 않다면 필요한 것부터 수시로 가져와서 실행, 사용자의 요청이 없더라도 앞으로 필요할 것이라고 예상되는 데이터를 미리 가져오기도 한다.
	- 배치 : 가져온 프로세스와 데이터를 메모리의 어떤 부분에 올려놓을지 결정
	- 재배치 : 메모리가 꽉 찼을 경우, 메모리에 있는 프로세스를 하드디스크로 옮기고 새로운 프로세스를 메모리에 가져오기 위해 오래된 프로세스를 내보내는 작업
 
### (4) 메모리 주소
 * 물리 주소 공간 : 하드웨어 입장에서의 메모리의 주소 공간, 물리주소 0번지부터 시작 ( 절대 주소 )
 * 논리 주소 공간 : 사용자의 입장에서의 메모리의 주소 공간, 물리주소와 관계없이 항상 0번지부터 시작 ( 상대 주소 )

### (5) 단일 프로그래밍 환경에서의 메모리 할당
* 메모리 오버레이 : 프로그램의 크기가 실제 메모리보다 클 때 전체 프로그램을 메모리에 가져오는 대신 적당한 크기로 잘라서 가져오는 기법
* 스왑 영역 : 메모리가 모자라서 쫓겨난 프로세스들을 저장하는 저장장치 내 공간, 메모리 관리자가 관리

### (6) 다중 프로그래밍 환경에서의 메모리 할당

* 분할 방식
	-  가변 분할 방식 : 세그멘테이션, 프로세스의 크기에 따라 메모리를 나누는 것, 하나의 프로세스를 연속된 공간에 배치, 메모리 통합 작업이 필요하므로 관리가 복잡함 ( 17KB, 18KB가 나눠서 비었을 때 30KB를 할당하기 위해선 합쳐야함, 외부 단편화 )
	-  고정 분할 방식 : 페이징, 프로세스의 크기와 상관없이 메모리를 같은 크기로 나누는 것, 메모리 관리가 수월, 쓸모없는 공간으로 인해 메모리 낭비( 20KB 에 18KB 할당, 내부 단편화 )


* 배치 방식
	- 최초 배치 : 메모리에서 적재 가능한 공간 중 첫 번째에 배치하는 방법
	- 최적 배치 : 빈 공간을 모두 확인한 후, 적당한 크기 가운데 가장 작은 공간에 배치하는 방법  	
	- 최악 배치 : 빈 공간을 모두 확인한 후, 가장 큰 공간에 배치하는 방법

* 버디 시스템
	- 1) 프로세스의 크기에 맞게 메모리를 1/2로 나눠가면서 메모리에 배치
	- 2) 나뉜 메모리의 각 구역에는 프로세스가 1개만 들어간다.
	- 3) 프로세스가 종료되면 주변의 빈 조각과 합쳐서 하나의 큰 덩어리를 만든다
	- 장점 : 비슷한 크기의 덩어리가 서로 모여 있어서 통합하기가 쉽다.

### 연습문제
1. 소스코드를 한 번에 번역하지 않고 한 행씩 번역하여 실행하는 방식을 무엇이라 하는가?
	- 인터프리터
2. 프로그래머가 C나 자바로 소스코드를 작성하여 컴파일하면 일차적으로 만들어지는 코드는 무엇인가?
	- 목적 코드
3. 컴파일할 때 코드에 라이브러리를 연결하지 않고 코드를 실행할 때 라이브러리를 가져와 실행하는 방식을 무엇이라 하는가?
	- 동적 라이브러리
4. 메모리 관리 정책 중 메모리가 꽉 찼을 때 메모리에 있는 어떤 프로세스를 내보낼지 결정하는 것은 무엇인가?
	- 재배치 작업
5. 32bit CPU를 사용하는 컴퓨터가 가질 수 있는 물리 메모리의 최대 크기는 무엇인가?
	- 2^32B(약 4GB)
6. 절대 주소는 실제 물리 주소로, 메모리 관리자 입장에서 바라본 주소이다. 절대 주소와 관계없이 사용자 입장에서 항상 0번지부터 시작하는 주소는 무엇인가?
	- 상대 주소
7. 상대 주소를 절대 주소로 변환할 때 사용하는 레지스터는 무엇인가?
	- 재배치 레지스터
8. 프로세스의 크기가 물리 메모리보다 클 때 전체 프로세스를 메모리로 가져오는 대신 적당한 크기로 잘라서 가져오는 기법은 무엇인가?
	- 메모리 오버레이
9. 메모리 영역이 부족해서 쫓겨난 프로세스를 보관하는 저장장치의 특별한 공간은 무엇인가?
	- 스왑 영역
10. 가변 분할 방식에서 사용하지 못하는 작은 메모리 공간이 발생하는 현상을 무엇이라 하는가?
	- 외부 단편화
11. 고정 분할 방식에서 똑같이 나누어진 메모리 공간에 작은 조각이 발생하는 현상을 무엇이라 하는가?
	- 내부 단편화
12. 가변 분할 방식의 메모리 배치 방식 중 프로세스를 배치하기에 적당한 공간 가운데 가장 작은 공간에 배치하는 방식은 무엇인가?
	- 최적 배치
13. 가변 분할 방식의 메모리 배치 방식 중 첫 번째로 발견한 빈 공간에 프로세스를 배치하는 방식은 무엇인가?
	- 최초 배치
14. 가변 분할 방식의 메모리 배치 방식 중 가장 큰 공간에 프로세스를 배치하는 방식은 무엇인가?
	- 최악 배치
15. 가변 분할 방식에서 서로 떨어진 여러 개의 빈 공간을 합치는 작업을 무엇이라 하는가?
	- 조각 모음
16. 메모리 분할 방식 중 프로세스의 크기에 맞도록 1/2크기로 잘라가면서 메모리를 나누어주는 방식은 무엇인가?
	- 버디 시스템

### 심화문제	
1. 컴파일러와 인터프리터를 비교하여 설명하시오
	- 컴파일러 : 소스코드를 컴퓨터가 실행할 수 있는 기계어로 번역한 후, 한꺼번에 실행한다. ( C, JAVA 등 )
	- 소스코드를 한 행씩 번역하여 실행한다. ( 자바스크립트, 베이직 등 )
2. 컴파일 과정에 대해 설명하시오
	- 1) 소스코드 작성 및 컴파일 : 소스코드를 작성후 일차로 번역하여 목적코드 생성
	- 2) 목적코드와 라이브러리 연결
	- 3) 동적 라이브러리를 포함하여 최송 실행 
3. 메모리 관리자가 수행하는 세 가지 작업에 대해 설명하시오
	- 가져오기 : 프로세스와 데이터를 메모리로 가져오는 것, 메모리가 충분하지 않다면 필요한 것부터 수시로 가져와서 실행, 사용자의 요청이 없더라도 앞으로 필요할 것이라고 예상되는 데이터를 미리 가져오기도 한다.
	- 배치 : 가져온 프로세스와 데이터를 메모리의 어떤 부분에 올려놓을지 결정
	- 재배치 : 메모리가 꽉 찼을 경우, 메모리에 있는 프로세스를 하드디스크로 옮기고 새로운 프로세스를 메모리에 가져오기 위해 오래된 프로세스를 내보내는 작업
4. 절대 주소와 상대 주소에 대해 설명하시오
	- 물리 주소 공간 : 하드웨어 입장에서의 메모리의 주소 공간, 물리주소 0번지부터 시작 ( 절대 주소 )
 	- 논리 주소 공간 : 사용자의 입장에서의 메모리의 주소 공간, 물리주소와 관계없이 항상 0번지부터 시작 ( 상대 주소 )
5. 가변 분할 방식의 장단점을 설명하시오
	-  가변 분할 방식 : 세그멘테이션, 프로세스의 크기에 따라 메모리를 나누는 것, 하나의 프로세스를 연속된 공간에 배치, 메모리 통합 작업이 필요하므로 관리가 복잡함 ( 17KB, 18KB가 나눠서 비었을 때 30KB를 할당하기 위해선 합쳐야함, 외부 단편화 )
6. 고정 분할 방식의 장단점을 설명하시오
	-  고정 분할 방식 : 페이징, 프로세스의 크기와 상관없이 메모리를 같은 크기로 나누는 것, 메모리 관리가 수월, 쓸모없는 공간으로 인해 메모리 낭비( 20KB 에 18KB 할당, 내부 단편화 )
7. 버디 시스템에 대해 설명하시오
	- 1) 프로세스의 크기에 맞게 메모리를 1/2로 나눠가면서 메모리에 배치
	- 2) 나뉜 메모리의 각 구역에는 프로세스가 1개만 들어간다.
	- 3) 프로세스가 종료되면 주변의 빈 조각과 합쳐서 하나의 큰 덩어리를 만든다
	- 장점 : 비슷한 크기의 덩어리가 서로 모여 있어서 통합하기가 쉽다.

---
## 7. 가상 메모리의 기초

### (1) 가상메모리
	- 물리 메모리의 크기와 상관없이 프로세스에 커다란 메모리 공간을 제공하는 기술
	- 동적 주소 변환 : 가상 주소를 실제 메모리의 물리 주소로 변환
	
	
### (2) 페이징 기법
	- 물리 주소 공간을 같은 크기로 나누어 사용, 프레임
	- 페이지 테이블 : 가상주소의 각 페이지가 물리 메모리의 어디에 위치하는지를 나타내는 맵핑 정보 테이블, 물리 메모리상 운영체제 영역, 각 줄을 페이지 테이블 엔트리라고 부른다.
	- 페이지 테이블 레지스터 : 각 프로세스가 각 페이지 테이블의 시작 주소를 보관하여, 빠르게 접근
	- VA = <P,D> , PA = <F,D>
	- 직접 맵핑 : 페이지 테이블 전체가 물리 메모리의 운영체제 영역에 존재하는 방식
	- 연관 맵핑 : 페이지 테이블 전체를 스왑 영역에서 관리하는 방식, 페이지 테이블 일부(변환 색인 버퍼, 연관 레지스터)를 물리 메모리에 가져오는 방식
	- 집합 연관 맵핑 : 연관 맵핑과 비슷하지만, 페이지 테이블을 일정한 집합으로 자르고, 자른 더어리 단위로 물리 메모리에 올리는 것, 집합 테이블로 해당 집합이 어디에 있는지 표시
	- 역맵핑 : 프레임 번호를 기준으로 어떤 프로세스의 어떤 페이지가 올라와 있는지를 표시, 페이지 테이블의 크기는 작지만 모두 검색해야함
	
### (3) 세그멘테이션 기법
	- 세그멘테이션 맵핑 테이블 : 세그먼트의 크기(limit), 물리 메모리상 시작주소(address)로 이뤄짐
	- 물리 메모리의 외부 단편화로 인해 물리 메모리 관리가 복잡
	- VA = <S,D>
	- 메모리 접근 권한
		- 코드 영역 : 자기 자신을 수정하는 프로그램은 없기 때문에 읽기 및 실행 권한을 가진다.
		- 데이터 영역 : 읽거나 쓸 수 있수 있는 데이터(변수), 읽기만 가능한 데이터(상수)
		- 추가권한은 항상 쓰기 권한이 동반되어야 한다.
		- 가상주소에서 물리주소로 주소 변환이 일어날 때마다 접근 권한 검사 시행
	- 세그멘테이션-페이징 혼용 기법
		- 페이지 테이블의 모든 행에 접근 권한과 관련된 권한 비트 추가
		- 가상 주소 공간에서 서로 관련있는 영역을 하나의 세그먼트로 묶어 세그멘테이션 테이블로 관리
		- 각 세그먼트를 구성하는 페이지를 해당 페이지 테이블로 관리
		- 각 세그멘테이션 테이블은 자신과 연결된 페이지 테이블의 시작 주소를 가진다.
	
### (4) 캐시 매핑 기법
	- 캐시 직접 맵핑
		- 캐시를 일정 크기로 나눠서 관리하는 방법, 페이지
		- 메모리는 N개, 캐시는 M개의 페이지로 구성
		- N/M (Block) 단위로 메모리를 자른다.
		- 메모리의 블록이 캐시로 올라올 때 항상 같은 위치에 올라온다. 즉 블록의 첫 번째 페이지는 캐시의 첫 번째 페이지, 블록의 두 번째 페이지는 캐시의 두 번째 페이지
		- VA = <tag,bd,?
		
	- 캐시 연관 맵핑
		- 캐시가 메모리 워드의 주소를 모두 가지고 있음
		- 캐시 히트, 미스를 확인하기 위해 캐시의 모든 주소를 검색해야 함
	
	- 캐시 집합-연관 맵핑
		- 캐시를 k개의 집합으로 나누고, 각 집합에 직접 맵핑을 사용
		
### (5) 연습문제
1. 가상 메모리에서 메모리 관리자가 사용할 수 있는 전체 크기는 어떻게 결정되는가?
	- 물리 메모리 + 스왑 영역
2. 가상 주소에서 하나의 프로세스가 사용할 수 있는 최대 주소는 무엇과 연관이 있는가?
	- CPU 비트
3. 가상 메모리에서 가상 주소를 물리 주소로 변환하기 위해 사용하는 자료 구조를 무엇이라 하는가?
	- 매핑 테이블
4. 페이징 기법의 주소 변환 과정 식을 쓰시오.
	- VA = <P,D> -> PA = <F,D>
5. 페이지 테이블에서 각각의 한 줄을 무엇이라 쓰는가?
	- 페이지 테이블 엔트리
6. 가상 주소를 <P,D>로 변환하는 공식을 쓰시오.
	- P : [가상주소/페이지 크기] 의 몫
	- D : [가상주소/페이지 크기] 의 나머지
7. 각 페이지 테이블의 시작 주소를 가지고 있는 레지스터는 무엇인가?
	- PTBR
8. 페이지 테이블 매핑 방식 중, 모든 페이지 테이블을 스왑 영역에 저장하고 그중 일부만 물리 메모리에 무작위로 가지고 있는 방식은 무엇인가?
	- 연관 매핑
9. 페이지 테이블 매핑 방식 중, 모든 페이지 테이블을 물리 메모리에 보관하는 방식은 무엇인가?
	- 직접 매핑
10. 페이지 테이블 매핑 방식 중, 모든 페이지 테이블을 스왑 영역에 저장하고 페이지 테이블을 일정한 집합 단위로 물리 메모리에 보관하는 방식은 무엇인가?
	- 집합-연관 매핑
11. 페이지 테이블 매핑 방식 중, 물리 메모리의 프레임 번호를 기준으로 구성하는 방식은 무엇인가?
	- 역매핑
12. 연관 매핑에서 사용하는 테이블의 이름은 무엇인가?
	- 변환 색인 버퍼
13. 연관 매핑에서 원하는 데이터가 변환 색인 버퍼에 없는 상태를 무엇이라 하는가?
	- TBL 미스
14. 연관 매핑에서는 전체 매핑 테이블을 어디에 보관하는가?
	- 스왑 영역
15. 가상 메모리에서 메모리 관리자는 물리 메모리 영역과 스왑 영역을 합쳐서 프로세스가 사용하는 가상 주소를 실제 메모리의 물리 주소로 변환한다. 이러한 작업을 무엇이라 하는가?
	- 동적 주소 변환
16. 사용자 프로세스가 자신의 크기보다 더 큰 주소에 접근하려고 하면 메모리 관리자는 그 프로세스를 강제 종료한다. 이때 발생하는 오류를 무엇이라 하는가?
	- 트랩
17. 세그멘테이션-페이징 혼용 기법에서는 접근 권한을 어디에서 관리하는가?
	- 세그멘테이션 테이블

### (6) 심화 문제
1. 가상 메모리가 이론적으로 가질 수 있는 크기와 실제 운영되는 크기는 어떤 차이가 있는지 설명하시오.
	- 이론 : 스왑 영역을 사용함으로써, 무한대
	- 실제 : 물리 메모리의 최대 크기로 한정
2. 페이징 기법의 주소 변환 과정을 그림으로 그리고 설명하시오.
	![image](https://user-images.githubusercontent.com/95995592/149653542-4b720b50-5d1f-4170-9db9-cb8c0c3b90a8.png)

	- 가상 주소 31번지가 어느 페이지에 있는지 찾는다. 31번지는 페이지 3의 1번째 위치에 있다.
	- 페이지 테이블의 페이지 3으로 가서 해당 페이지가 프레임 1에 있다는 것을 알아낸다.
	- 프로세스가 저장하려는 값을 프레임 1의 1번 위치에 저장한다.
3. 연관 매핑의 동작을 설명하시오.
	- 페이지 테이블 전체를 스왑 영역에서 관리하는 방식, 페이지 테이블 일부(변환 색인 버퍼, 연관 레지스터)를 물리 메모리에 가져오는 방식
4. 집합-연관 매핑의 동작을 설명하시오.
	- 연관 맵핑과 비슷하지만, 페이지 테이블을 일정한 집합으로 자르고, 자른 더어리 단위로 물리 메모리에 올리는 것, 집합 테이블로 해당 집합이 어디에 있는지 표시
5. 역매핑의 동작을 설명하시오.
	- 프레임 번호를 기준으로 어떤 프로세스의 어떤 페이지가 올라와 있는지를 표시, 페이지 테이블의 크기는 작지만 모두 검색해야함
6. 세그멘테이션-페이징 혼용 기법을 사용하는 이유를 설명하시오.
	- 페이징 기법은 메모리 관리가 수월한 반면 페이지 테이블의 크기가 크고, 세기멘테이션 기법은 페이지테이블의 크기를 작게 유지하지만 물리 메모리의 외부 단편화로 인해 추가적인 관리가 필요하기 때문에, 페이징 기법에 세그멘테이션 테이블을 추가하고 권한 비트와 같이 중복되는 데이터를 세그멘테이션 테이블로 옮겨 오면 테이블의 크기를 줄일 수 있음. 
