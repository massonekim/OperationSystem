## 목차

1. [운영체제의 개요](#1.-운영체제의-개요)   
2. [프로세스와 스레드](#2.-프로세스와-스레드)   
3. [CPU 스케줄링](#3.-CPU-스레드)   

---
## 1. 운영체제의 개요

### (1) 운영체제 정의

* 사용자에게 편리한 인터페이스 환경을 제공하고 컴퓨터 시스템의 자원을 효울적으로 관리하는 소프트웨어

### (2) 운영체제 역할

#### 자원관리 ( 목표 : 효율성 )
* 컴퓨터 자원 배분 및 회수
#### 자원보호 ( 목표 : 안정성 )
* 비정상적인 작업으로부터 자원 보호
#### 하드웨어 인터페이스 제공 ( 목표 : 확장성 )
* 다양한 하드웨어 장치를 사용할 수 있도록 인터페이스 제공
#### 사용자 인터페이스 제공 ( 목표 : 편리성 )
* 사용자가 운영체제를 편리하게 사용할 수 있도록 지원

### (3) 운영체제 구조

#### 커널
* 프로세스 관리, 메모리 관리, 저장장치 관리와 같은 핵심적인 기능을 모아놓은 것
* 프로세스 관리 : 프로세스에 CPU를 배분하고 작업에 필요한 제반 환경 제공
* 메모리 관리 : 프로세스에 작업 공간을 배치하고 실제 메모리보다 큰 가상공간 제공
* 파일 시스템 관리 : 데이터를 저장하고 접근할 수 있는 인터페이스 제공
* 입출력 관리 : 필요한 입력과 출력 서비스 제공
* 프로세스 간 통신 관리 : 공동 작업을 위한 각 프로세스 간 통신 환경 지원

#### 시스템 호출
* 사용자나 응용 프로그램으로부터 컴퓨터 자원을 보호하기 위해 자원에 직접 접근하는 것을 차단하고 보호하기 위해 만든 인터페이스

#### 드라이버
* 운영체제가 많은 하드웨어를 모두 사용할 수 있는 환경을 제공할 수는 없기에, 커널은 입출력의 기본적인 부분만 제공하고 하드웨어의 특성을 반영한 소프트웨어는 디바이스 드라이버의 형태로 커널이 실행될 때 함께 실행

#### 인터페이스
* 사용자와 응용 프로그램에 인접하여 커널에 명령을 전달하고 실행 결과를 사용자와 응옹 프로그램에 돌려주는 역할

---
## 2. 프로세스와 스레드

### (1) 프로세스 개념
* 실행 중인 프로그램

### (2) 프로세스 상태
* 생성 : 프로세스가 메모리에 올라와 실행 준비를 완료한 상태, 프로세스 제어 블록(PCB) 생성
* 준비 : 생성된 프로세스가 CPU에 올라갈 때까지 기다리는 상태
* 실행 : CPU에 올라가 실제 작업을 수행하는 상태
* 완료 : 프로세스가 종료된 상태. 프로세스 제어 블록(PCB) 삭제
* 대기 : 실행 상태에 있는 프로세스가 입출력을 요청하면 입출력이 완료될 때까지 기다리는 상태. 입출력이 완료되면 준비 상태로 간다.

### (3) 프로세스 제어 블록(PCB)
* 프로세스를 실행하는 데 필요한 중요한 정보를 보관하는 자료 구조
* 포인터 : 프로세스 제어 블록의 첫 번째 블록에 위치하여 프로세스 제어 블록을 연결하여 준비상태나 대기상태의 큐를 구현하기 위한 것
* 프로세스 상태 : 프로세스가 현재 어떤 상태에 있는지를 나타내는 것
* 프로세스 구분자 : 운영체제 내에 있는 여러 프로세스를 구별하기 위한 구분자
* 프로그램 카운터 : 다음에 실행될 명령어의 위치를 가리키는 것
* 프로세스 우선순위 : CPU스케줄러가 준비상태 또는 대기상태에 있는 프로세스 중 실행 상태로 옮겨야 할 프로세스를 선택할 때 기준
* 각종 레지스터 정보 : 누산기, 색인 레지스터, 스택 포인터와 같은 이전에 실행할 때 사용한 레지스터의 값을 보관
* 메모리 관리 정보 : 프로세스가 메모리상의 위치 정보, 경계 레지스터값, 한계 레지스터 값 등을 저장
* 할당된 자원 정보 : 프로세스를 실행하기 위해 사용하는 입출력 자원이나 오픈 파일 등에 대한 정보
* 계정 정보 : 계정정보, CPU할당시간, CPU 사용시간 등을 저장
* 부모 프로세스 구분자와 자식 프로세스 구분자 : 부모, 자식 프로세스의 구분자(PID) 저장

### (4) 프로세스 구조
* 코드 영역 : 프로그램의 본문이 기술된 영역, 읽기 전용
* 데이터 영역 : 코드가 실행되면서 사용하는 변수나 파일 등의 각종 데이터를 모아놓은 곳, 읽기/쓰기
* 스택 영역 : 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳

### (5) 스레드 개념
* 프로세스의 코드에 정의된 절차에 따라 CPU에 작업 요청을 하는 실행 단위

### (6) 멀티스레드 개념
* 프로세스 내 작업을 여러 개의 스레드로 분할함으로써 작업의 부담을 줄이는 프로세스 운영 기법

### (7) 멀티스레드 장단점
#### 장점
* 응답성 향상 : 한 스레드가 입출력으로 인해 작업이 진행되지 않더라도, 다른 스레드가 작업을 계속하여 사용자의 작업 요구에 빠르게 응답
* 자원 공유 : 한 프로세스 내에서 독립적인 스레드를 생성하면 프로세스가 가진 자원을 모든 스레드가 공유하게 되어 작업을 원할하게 진행
* 효율성 향상 : 불필요한 자원의 중복을 막음으로써 시스템의 효율 향상 
* 다중 CPU 지원 : 2개 이상의 CPU를 가진 컴퓨터에서 멀티스레드를 사용하면 다중 CPU가 멀티스레드를 동시에 처리하여 CPU 사용량이 증가하고 프로세스의 처리 시간 단축
#### 단점
* 모든 스레드가 자원을 공유하기 떄문에 한 스레드에 문제가 생기면 전체 프로세스에 영향을 미친다.

### 연습문제
1. 프로그램이 프로세스가 되려면 운영체제로부터 무엇을 받아야 하는가?
* 프로세스 제어 블록(PCB)
2. 프로세스의 상태중 CPU를 할당받기 위해 기다리는 상태는 무엇인가?
* 준비 상태
3. 프로세스의 상태 중 입출력 작업을 하기 위해 이동하는 상태는 무엇인가?
* 대기 상태
4. CPU스케줄러가 준비상태에 있는 프로세스 중 하나를 골라 CPU를 할당하는 작업을 무엇이라고 하는가?
* 디스패치
5. 유닉스에서 CTRL+Z 키를 눌러 프로세스가 중단되면 프로세스는 어떤 상태로 바뀌는가?
* 휴식 상태
6. 실행 상태에서 하나의 프로세스가 나가고 새로운 프로세스가 들어오는 상황을 무엇이라고 하는가?
* 문맥 교환
7. 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 시스템 호출은 무엇인가?
* fork()
8. 프로세스의 골격은 그대로 둔 채 코드 영역만 바꾸는 시스템 호출은 무엇인가?
* exec()
9. 부모 프로세스가 기다리지 않아 자원이 회수되지 못하고 계속 살아 있는 프로세스는 무엇인가?
* 고아 프로세스
10. 프로세스의 코드에 정의된 절차에 따라 CPU에 작업 요청을 하는 실행 단위로서 가벼운 프로세스라고 불리는 것은 무엇인가?
* 스레드
11. 고아 프로세스를 방지하기 위해 부모 프로세스는 어떤 시스템 호출을 사용하는가?
* wait()
12. 작업이 끝난 프로세스의 자원을 회수하는 행위를 무엇이라고 하는가?
* Garbage collection
13. 모든 프로세스를 부모-자식 관계로 만들어 자원 회수를 용이하게 하는 프로세스의 구조는 무엇인가?
* 계층 구조

### 심화문제
1. 다섯 가지 프로세스 상태도를 그리시오.
* ![다운로드](https://user-images.githubusercontent.com/95995592/146670169-fb7ae22d-d67b-4f49-88db-a4897533724f.jpg)
2. 프로세스의 상태 중 휴식사앹와 보류상태에 대해 설명하시오.
* 휴식 상태 : 프로세스가 작업을 일시적으로 쉬고 있는 상태
* 보류 상태 : 프로세스가 메모리에서 잠시 쫓겨난 상태
3. 프로세스 제어 블록의 구성에 대해 설명하시오.
* 프로세스를 실행하는 데 필요한 중요한 정보를 보관하는 자료 구조
* 포인터 : 프로세스 제어 블록의 첫 번째 블록에 위치하여 프로세스 제어 블록을 연결하여 준비상태나 대기상태의 큐를 구현하기 위한 것
* 프로세스 상태 : 프로세스가 현재 어떤 상태에 있는지를 나타내는 것
* 프로세스 구분자 : 운영체제 내에 있는 여러 프로세스를 구별하기 위한 구분자
* 프로그램 카운터 : 다음에 실행될 명령어의 위치를 가리키는 것
* 프로세스 우선순위 : CPU스케줄러가 준비상태 또는 대기상태에 있는 프로세스 중 실행 상태로 옮겨야 할 프로세스를 선택할 때 기준
* 각종 레지스터 정보 : 누산기, 색인 레지스터, 스택 포인터와 같은 이전에 실행할 때 사용한 레지스터의 값을 보관
* 메모리 관리 정보 : 프로세스가 메모리상의 위치 정보, 경계 레지스터값, 한계 레지스터 값 등을 저장
* 할당된 자원 정보 : 프로세스를 실행하기 위해 사용하는 입출력 자원이나 오픈 파일 등에 대한 정보
* 계정 정보 : 계정정보, CPU할당시간, CPU 사용시간 등을 저장
* 부모 프로세스 구분자와 자식 프로세스 구분자 : 부모, 자식 프로세스의 구분자(PID) 저장
4. 문맥교환에 대해 설명하시오.
* CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업으로, 프로세스 제어 블록의 내용이 변경됨.
5. 프로세스를 구성하는 코드 영역, 데이터 영역, 스택 영역에 대해 설명하시오.
* 코드 영역 : 프로그램의 본문이 기술된 영역, 읽기 전용
* 데이터 영역 : 코드가 실행되면서 사용하는 변수나 파일 등의 각종 데이터를 모아놓은 곳, 읽기/쓰기
* 스택 영역 : 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳
6. fork() 시스템 호출의 장점을 설명하시오
* 기존 메모리에서 복사하는 구조로 프로세스의 생성 속도가 빠르다.
* 추가 자원 작업 없이 자원을 상속할 수 있다.
* 부모, 자식 프로세스 구분자로 연결되어 있음으로 정리를 부모 프로세스에 맡김으로써 시스템 관리를 효율적으로 할 수 있다.
7. exec() 시스템 호출을 사용하는 이유를 설명하시오.
* 프로세스의 구조체를 재활용함으로써, PCB, 메모리 영역, 부모-자식 관계를 그대로 사용할 수 있음으로 운영체제의 작업이 수월하다.
8. 프로세스 계층 구조의 장점을 설명하시오
* 동시에 여러 작업을 처리하고, 종료된 프로세스의 자원을 회수하는데 유용하다.
9. 멀티스레드, 멀티태스킹, 멀티프로세싱, CPU멀티스레드를 비교하여 설명하시오.
* 멀티스레드 : 프로세스 내 작업을 여러 개의 스레드로 분할함으로써 작업의 부담을 줄이는 프로세스 운영 기법
* 멀티태스킹 : 운영체제가 CPU에 작업을 줄 때 시간을 잘게 나누어(타임퀀텀) 배분하여, 여러 프로세스가 동시에 작업하는 것 처럼 보이게 배분하는 기법
* 멀티프로세싱 : CPU를 여러 개 사용하여 여러 개의 스레드를 동시에 처리하는 작업 환경
* CPU 멀티스레드 : 한 번에 하나씩 처리해야 하는 스레드를 파이프라인 기법을 이용하여 동시에 여러 스레드를 처리하도록 만든 병렬 처리 기법

---

## 3. CPU 스케줄링

### (1) CPU 스케줄링
  * 메모리에 올라온 프로세스들중 어떤 프로세스를 먼저 처리할지 일들의 순서를 정하는 것

### (2) 스케줄링 단계
  * 고수준 스케줄링 : 시스템 내의 전체 작업 수를 조절
  * 저수준 스케줄링 : 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 등을 결정
  * 중간 수준 스케줄링 : 중지와 활성화로 전체 시스템의 활성화된 프로세스 수를 조절하여 과부하 방지

### (3) 스케줄링 목적
  * 공평성 : 모든 프로세스가 자원을 공평하게 배정받아야 하며, 자원 배정 과정에서 특정 프로세스가 배제되어서는 안 된다.
  * 효율성 : 시스템 자원이 유휴 시간 없이 사용되도록 스케줄링 하고, 유휴 자원을 사용하려는 프로세스에는 우선권을 주어야 한다.
  * 안정성 : 우선순위를 사용하여 중요 프로세스가 먼저 작동하도록 배정함으로써 시스템 자원을 점유하거나 파괴하려는 프로세스로부터 자원 보호
  * 확장성 : 프로세스가 증가해도 시스템이 안정적으로 작동하도록 조치
  * 반응 시간 보장 : 적절한 시간 안에 프로세스의 요구에 반응
  * 무한 연기 방지 : 특정 프로세스의 작업이 무한히 연기되는 것을 방지

### (4) 스케줄링 시 고려 사항
  1. 선점형 스케줄링과 비선점형 스케줄링
    * 선점형 : 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 방식
      * 장점 : 프로세스가 CPU를 독점할 수 없어 대화형이나 시분할 시스템에 적합
      * 단점 : 문맥 교환의 오버헤드가 많다
    * 비선점형 : 어떤 프로세스가 CPU를 점유하면 다른 프로세스가 이를 빼앗을 수 없는 스케줄링 방식
      * 장점 : CPU 스케줄러의 작업량이 적고 문맥 교환의 오버헤드가 적다
      * 단점 : 기다리는 프로세스가 많아 처리율이 떨어진다
  2. 프로세스 우선순위 
    * 커널 프로세스
    * 일반 프로세스 
  3. CPU 집중 프로세스와 입출력 집중 프로세스
    * CPU 집중 : 수학 연산과 같이 CPU를 많이 사용하는 프로세스
    * 입출력 집중 : 저장장치에서 데이터를 복사하는 일과 같이 입출력을 많이 사용하는 프로세스
    * 입출력 집중 프로세스가 실행 상태로 가면 입출력 요구에 의해 대기 상태로 옮겨지기 때문에 다른 프로세스가 CPU를 사용할 수 있으므로, 입출력 집중 프로세스를 먼저 실행 상태로 옮기는 것이 효율적이다.
  4. 전면 프로세스와 후면 프로세스
    * 전면 프로세스(상호작용 프로세스)
      * GUI를 사용하는 운영체제에서 화면의 맨 앞에 놓인 프로세스 현재 입력과 출력을 사용하는 프로세스
    * 후면 프로세스(일괄 작업 프로세스)
      * 사용자와 상호작용이 없는 프로세스

### (5) 다중 큐
  1. 준비 상태의 다중 큐
    * 준비 상태에 들어올 때마다 자신의 우선순위에 해당하는 큐의 마지막에 삽입
    * 고정 우선순위 방식 
      * 운영체제가 프로세스에 우선순위를 부여하면 프로세스가 끝날 때까지 바뀌지 않는 방식
      * 시스템의 상황이 시시각각 변하는데 우선순위를 고정하면 시스템의 변화에 대응하기 어려워 작업 효율이 떨어짐
    * 변동 수선순위 방식
      * 프로세스 생성 시 부여받은 우선순위가 프로세스 작업 중간에 변하는 방식
      * 구현하기 어렵지만, 시스템의 효율성을 높일 수 있음
  2. 대기 상태의 다중 큐
    * 같은 입출력을 요구한 프로세스끼리 모아놓은 다중 큐
    * 입출력이 동시에 끝날 경우 여러 개의 인터럽트가 한꺼번에 처리됨으로, 인터럽트 벡터라는 자료구조를 이용

### (6) 스케줄링 알고리즘
  1. 스케줄링 알고리즘의 선택 기준
    * CPU 사용률 : 전체 시스템의 동작 시간 중 CPU가 사용된 시간
    * 처리량 : 단위 시간당 작업을 마친 프로세스의 수
    * 대기 시간 : 작업을 요청한 프로세스가 작업을 시작하기 전까지 대기하는 시간
    * 응답 시간 : 프로세스 시작 후 첫 번째 출력 또는 반응이 나올 때까지 걸리는 시간
    * 반환 시간 : 프로세스가 생성된 후 종료되어 사용하던 자원을 모두 반환하는 데까지 걸리는 시간
  2. FCFS 스케줄링
    * 준비 큐에 도착한 순선대로 CPU를 할당하는 비선점형 방식
  3. SJF 스케줄링
    * 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 방식
  4. HRN 스케줄링
    * 최고 응답률 우선 스케줄링
    * 우선순위 : ( 대기시간 + CPU 사용시간 ) / CPU 사용 시간
  5. 라운드 로빈 스케줄링
    * 한 프로세스가 할당받은 시간동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식
    * 타임 슬라이스를 너무 작게 설정하면 문맥 교환이 너무 자주 일어나서 시스템의 전반적인 성능이 떨어진다.
  6. SRT 우선 스케줄링
    * 최소 잔류 시간 우선 스케줄링
    * 남은 시간을 주기적으로 계산하고, 남은 시간이 더 적은 프로세스와 문맥교환을 해야 하므로 추가 작업이 필요
  7. 우선순위 스케줄링
    * 우선순위를 반영한 스케줄링
  8. 다단계 큐 스케줄링
    * 우선순위에 따라 준비 큐를 여러개 사용하는 방식
    * 고정형 우선순위
  9. 다단계 피드백 큐 스케줄링
    * CPU를 사용하고 난 프로세스의 우선순위가 낮아지는 방식의 다단계 큐 스케줄링
    * 마지막 큐는 타임 슬라이스를 무한대로 해서 FCFS 스케줄링 방식

### (7) 인터럽트
  * 개념
    * 입출력 하드웨어 등의 장치에 예외상황이 발생하여 처리가 필요할 경우에 CPU에 알려 처리할 수 있도록 하는 것
  * 동기적 인터럽트 : 프로세스가 실행 중인 명령어로 인해 발생
    * 프로그램상의 문제 때문에 발생하는 인터럽트
    * 컴퓨터 작업자가 의도적으로 프로세스를 중단하기 위해 발생시킨 인터럽트
    * 입출력장치 같은 주변장치의 조작에 의한 인터럽트
    * 산술 연산 중 발생하는 인터럽트
  * 비동기적 인터럽트 : 하드디스크 읽기 오류, 메모리 불량과 같은 하드웨어적인 오류로 발생
  * 인터럽트 처리 과정
    1. 현재 실행 중인 프로세스는 일시 정지 상태
    2. 인터럽트 컨트롤러가 실행되어 인터럽트의 처리 순서를 결정
    3. 인터럽트 벡터에 등록된 인터럽트 핸들러 실행
    4. 인터럽트 처리를 마치면 일시 정지된 프로세스가 다시 실행되거나 종료


### 연습문제
  1. 시스템 내 전체 프로세스의 수를 조절하는 것으로, 장기 스케줄링 또는 작업 스케줄링이라 불리는 스케줄링 수준은 무엇인가?
    * 고수준 스케줄링
  2. 어떤 프로세스에 CPU를 할당하고 어떤 프로세스를 대기 상태로 보낼지 등을 결정하는 스케줄링 수준은 무엇인가?
    * 저수준 스케줄링
  3. 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 스케줄링은 무엇인가?
    * 선점형 스케줄링
  4. 현재 입출력을 진행하는 프로세스로, 사용자와 상호작용이 가능하여 상호작용 프로세스라고도 불리는 것은 무엇인가?
    * 전면 프로세스
  5. 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 스케줄링 알고리즘은 무엇인가?
    * FCFS 스케줄링
  6. 준비 큐에 있는 프로세스 중 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 스케줄링 알고리즘은 무엇인가?
    * SJF 스케줄링
  7. SJF 스케줄링 알고리즘의 단점으로 크기가 큰 작업이 계속 뒤로 밀리는 현상을 무엇이라 하는가?
    * 아사 현상
  8. 아사 현상을 해결하는 방법을 설명하시오.
    * 에이징 : 프로세스가 양보할 수 있는 상한선을 정하는 방식
  9. 서비스를 받기 위해 대기한 시간과 CPU 사용 시간을 고려하여 우선순위를 정하는 스케줄링 알고리즘은 무엇인가?
    * HRN 스케줄링
  10. 프로세스가 할당받은 시간(타임 슬라이스)동안 작업하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 다음 자기 차례가 올 때까지 기다리는 선점형 스케줄링 알고리즘 중 가장 단순한 것은 무엇인가?
    * 라운드 로빈 스케줄링
  11. 타임 슬라이스의 크기와 문맥 교환의 관계를 설명하시오.
    * 타임 슬라이스를 너무 작게 설정하면 문맥 교환이 너무 자주 일어나 문맥 교환에 걸리는 시간이 실제 작업 시간보다 상대적으로 커지며, 문맥 교환에 많은 시간을 낭비하여 실제 작업을 못하는 문제가 발생
  12. 기본적으로 라운드 로빈 방식을 사용하지만, CPU를 할당받을 프로세스를 선택할 때 남아있는 작업 시간이 가장 적은 것을 선택하는 스케줄링 알고리즘은 무엇인가?
    * SRT 우선 스케줄링
  13. 우선순위에 따라 준비 큐를 여러 개 사용하며 고정형 우선순위를 적용하는 스케줄링 알고리즘은 무엇인가?
    * 우선순위 스케줄링
  14. 우선순위에 따라 준비 큐를 여러 개 사용하며, 프로세스가 CPU를 사용한 후 우선순위가 낮아지는 특징을 가진 스케줄링 알고리즘은 무엇인가?
    * 다단계 피드백 큐 스케줄링
  15. 다단계 피드백 큐 스케줄링에서 마지막 큐에 있는 프로세스(우선순위가 가장 낮은 프로세스)의 타임 슬라이스 크기는 얼마인가?
    * 무한대
  16. 다단계 피드백 큐 스케줄링에서 우선순위가 낮아질수록 타임 슬라이스의 크기는 어떻게 변하는가?
    * 우선순위가 낮아질수록 해당 큐의 타임 슬라이스가 커진다.
  17. 다단계 피드백 큐 스케줄링에서 마지막 큐(우선순위가 가장 낮은 큐)는 어떤 스케줄링 알고리즘처럼 동작하는가?
    * FCFS 스케줄링

### 심화문제
  1. 스케줄링의 단계와 그 특징을 설명하시오.
    * 고수준 스케줄링 : 시스템 내의 전체 작업 수를 조절
    * 저수준 스케줄링 : 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 등을 결정
    * 중간 수준 스케줄링 : 중지와 활성화로 전체 시스템의 활성화된 프로세스 수를 조절하여 과부하 방지 
  2. 스케줄링의 목적을 설명하시오.
    * 공평성 : 모든 프로세스가 자원을 공평하게 배정받아야 하며, 자원 배정 과정에서 특정 프로세스가 배제되어서는 안 된다.
    * 효율성 : 시스템 자원이 유휴 시간 없이 사용되도록 스케줄링 하고, 유휴 자원을 사용하려는 프로세스에는 우선권을 주어야 한다.
    * 안정성 : 우선순위를 사용하여 중요 프로세스가 먼저 작동하도록 배정함으로써 시스템 자원을 점유하거나 파괴하려는 프로세스로부터 자원 보호
    * 확장성 : 프로세스가 증가해도 시스템이 안정적으로 작동하도록 조치
    * 반응 시간 보장 : 적절한 시간 안에 프로세스의 요구에 반응
    * 무한 연기 방지 : 특정 프로세스의 작업이 무한히 연기되는 것을 방지
  3. 선점형 스케줄링과 비선점형 스케줄링을 비교하여 설명하시오.
    * 선점형 : 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 방식
      * 장점 : 프로세스가 CPU를 독점할 수 없어 대화형이나 시분할 시스템에 적합
      * 단점 : 문맥 교환의 오버헤드가 많다
    * 비선점형 : 어떤 프로세스가 CPU를 점유하면 다른 프로세스가 이를 빼앗을 수 없는 스케줄링 방식
      * 장점 : CPU 스케줄러의 작업량이 적고 문맥 교환의 오버헤드가 적다
      * 단점 : 기다리는 프로세스가 많아 처리율이 떨어진다
  4. 스케줄링 알고리즘의 선택 기준에 대해 설명하시오.
    * CPU 사용률 : 전체 시스템의 동작 시간 중 CPU가 사용된 시간
    * 처리량 : 단위 시간당 작업을 마친 프로세스의 수
    * 대기 시간 : 작업을 요청한 프로세스가 작업을 시작하기 전까지 대기하는 시간
    * 응답 시간 : 프로세스 시작 후 첫 번째 출력 또는 반응이 나올 때까지 걸리는 시간
    * 반환 시간 : 프로세스가 생성된 후 종료되어 사용하던 자원을 모두 반환하는 데까지 걸리는 시간
  5. FCFS, SJF, HRN 스케줄링의 특징을 설명하시오
    * FCFS 스케줄링
      * 준비 큐에 도착한 순선대로 CPU를 할당하는 비선점형 방식
    * SJF 스케줄링
      * 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 방식
    * HRN 스케줄링
      * 최고 응답률 우선 스케줄링
      * 우선순위 : ( 대기시간 + CPU 사용시간 ) / CPU 사용 시간
  6. 라운드 로빈, SRT, 다단계 큐, 다단계 피드백 큐 스케줄링의 특징을 설명하시오.
    * 라운드 로빈 스케줄링
      * 한 프로세스가 할당받은 시간동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식
      * 타임 슬라이스를 너무 작게 설정하면 문맥 교환이 너무 자주 일어나서 시스템의 전반적인 성능이 떨어진다.
    * SRT 우선 스케줄링
      * 최소 잔류 시간 우선 스케줄링
      * 남은 시간을 주기적으로 계산하고, 남은 시간이 더 적은 프로세스와 문맥교환을 해야 하므로 추가 작업이 필요
    * 다단계 큐 스케줄링
      * 우선순위에 따라 준비 큐를 여러개 사용하는 방식
      * 고정형 우선순위
    * 다단계 피드백 큐 스케줄링
      * CPU를 사용하고 난 프로세스의 우선순위가 낮아지는 방식의 다단계 큐 스케줄링
      * 마지막 큐는 타임 슬라이스를 무한대로 해서 FCFS 스케줄링 방식 
  7. 아사 현상과 에이징에 대해 설명하시오.
    *  아사 현상 : 특정 프로세스가 다른 프로세스에 밀려 CPU를 사용하지 못하고 계속해서 뒤로 밀리는 현상
    *  에이징 : 프로세스가 양보할 수 있는 상한선을 정하는 방식 
  8. 타임 슬라이스의 크기를 정하는 것과 시스템 효율성에 대해 설명하시오
    * 타임 슬라이스가 큰 경우 : 하나의 작업이 끝난 뒤, 다음 작업이 사직되는 것처럼 보인다.
    * 타임 슬라이스가 작은 경우 : 타임 슬라이스를 너무 작게 설정하면 문맥 교환이 너무 자주 일어나 문맥 교환에 걸리는 시간이 실제 작업 시간보다 상대적으로 커지며, 문맥 교환에 많은 시간을 낭비하여 실제 작업을 못하는 문제가 발생
---
